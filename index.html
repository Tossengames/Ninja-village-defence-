<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Silent House: Mobile Stealth Pro</title>
<style>
    body { margin: 0; background: #0f0f0f; color: #eee; font-family: 'Courier New', monospace; text-align: center; touch-action: none; overflow: hidden; }
    canvas { display: block; margin: 0 auto; background: #1a1a1a; cursor: crosshair; }
    button { padding: 10px 20px; margin: 5px; background: #333; color: #0af; border: 1px solid #444; border-radius: 4px; font-weight: bold; }
    button:active { background: #0af; color: #000; }
    .hidden { display: none; }
    #ui-layer { position: fixed; width: 100%; pointer-events: none; z-index: 10; }
    #controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); pointer-events: auto; }
    #info { top: 20px; left: 50%; transform: translateX(-50%); max-width: 80%; }
    .message { background: rgba(0,0,0,0.85); padding: 6px 12px; border-left: 3px solid #0af; margin-bottom: 5px; font-size: 14px; animation: fadeIn 0.3s; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
</style>
</head>
<body>

<div id="menu">
    <h1 style="color:#0af">SILENT HOUSE</h1>
    <p>Level: <span id="levelText">1</span></p>
    <button onclick="changeLevel(-1)">-</button>
    <button onclick="changeLevel(1)">+</button><br><br>
    <p>Map Size:</p>
    <input type="number" id="mapWidth" value="12" style="width:50px"> x 
    <input type="number" id="mapHeight" value="12" style="width:50px"><br><br>
    <button onclick="startGame()">START MISSION</button>
</div>

<div id="ui-layer">
    <div id="info"></div>
</div>

<canvas id="game" class="hidden"></canvas>

<div id="controls" class="hidden">
    <button onclick="playerWait()">STAY STILL</button>
    <button onclick="backToMenu()">ABORT</button>
</div>

<script>
/* ===== CONFIG & STATE ===== */
const TILE = 48;
const FLOOR=0, WALL=1, NOISE=2, EXIT=3, HIDE=4;
let levelNumber = 1, grid, player, enemies, gameOver = false, playerTurn = true;
let mapW, mapH;

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const info = document.getElementById("info");

let camera = { x: 0, y: 0, scale: 1 };
let isDragging = false, lastX, lastY;

/* ===== CORE ENGINE ===== */
function changeLevel(v) { levelNumber = Math.max(1, levelNumber + v); document.getElementById("levelText").textContent = levelNumber; }

function startGame() {
    mapW = parseInt(document.getElementById("mapWidth").value);
    mapH = parseInt(document.getElementById("mapHeight").value);
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Initial Camera Center
    camera.scale = Math.min(window.innerWidth / (mapW * TILE), window.innerHeight / (mapH * TILE), 1.2);
    camera.x = (canvas.width - (mapW * TILE * camera.scale)) / 2;
    camera.y = (canvas.height - (mapH * TILE * camera.scale)) / 2;

    document.getElementById("menu").classList.add("hidden");
    canvas.classList.remove("hidden");
    document.getElementById("controls").classList.remove("hidden");
    generateLevel();
}

function generateLevel() {
    gameOver = false; playerTurn = true;
    grid = Array.from({length: mapH}, (_, y) => Array.from({length: mapW}, (_, x) => 
        (x===0 || y===0 || x===mapW-1 || y===mapH-1) ? WALL : Math.random() < 0.18 ? WALL : FLOOR
    ));

    // Place Exit
    let ex, ey; do { ex = Math.floor(Math.random()*mapW); ey = Math.floor(Math.random()*mapH); } while(grid[ey][ex] !== FLOOR);
    grid[ey][ex] = EXIT;

    // Place Player
    let px, py; do { px = Math.floor(Math.random()*mapW); py = Math.floor(Math.random()*mapH); } 
    while(grid[py][px] !== FLOOR || Math.hypot(px-ex, py-ey) < 6);
    player = { x: px, y: py, hidden: false, animX: px, animY: py };

    // Props
    for(let i=0; i<levelNumber+2; i++) placeRandom(NOISE);
    for(let i=0; i<3; i++) placeRandom(HIDE);

    // Enemies
    enemies = [];
    const eCount = Math.min(2 + Math.floor(levelNumber/2), 8);
    for(let i=0; i<eCount; i++) {
        let enX, enY; do { enX = Math.floor(Math.random()*mapW); enY = Math.floor(Math.random()*mapH); }
        while(grid[enY][enX] !== FLOOR || Math.hypot(enX-px, enY-py) < 4);
        enemies.push({
            x: enX, y: enY, animX: enX, animY: enY,
            dir: {x: Math.random() > 0.5 ? 1 : -1, y: 0},
            target: null, alert: 0, vision: 3
        });
    }
    showMessage("MISSION START: Reach the Extraction Point.");
    draw();
}

function placeRandom(type) {
    let x, y; do { x = Math.floor(Math.random()*mapW); y = Math.floor(Math.random()*mapH); } while(grid[y][x] !== FLOOR);
    grid[y][x] = type;
}

/* ===== MOVEMENT LOGIC ===== */
function getMovableTiles() {
    const reachable = [];
    const dirs = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}, {x:1,y:1}, {x:-1,y:-1}, {x:1,y:-1}, {x:-1,y:1}];
    
    // 1-step moves
    dirs.forEach(d => {
        let nx = player.x + d.x, ny = player.y + d.y;
        if(isValid(nx, ny)) {
            reachable.push({x: nx, y: ny});
            // 2nd step from this position
            dirs.forEach(d2 => {
                let nnx = nx + d2.x, nny = ny + d2.y;
                if(isValid(nnx, nny) && (nnx !== player.x || nny !== player.y)) {
                    if(!reachable.some(r => r.x === nnx && r.y === nny)) reachable.push({x: nnx, y: nny});
                }
            });
        }
    });
    return reachable;
}

function isValid(x, y) { return x >= 0 && y >= 0 && x < mapW && y < mapH && grid[y][x] !== WALL; }

function movePlayerTo(tx, ty) {
    if(!playerTurn || gameOver) return;
    playerTurn = false;
    
    // Path animation
    const path = [];
    // Simple 2-step logic: move to target
    if(Math.abs(tx - player.x) <= 2 && Math.abs(ty - player.y) <= 2) {
        path.push({x: tx, y: ty});
    }

    animatePath(player, path, () => {
        checkPlayerTile();
        enemyTurn();
    });
}

function animatePath(entity, path, callback) {
    if(path.length === 0) { callback(); return; }
    const next = path.shift();
    entity.x = next.x; entity.y = next.y;
    
    let start = null;
    const duration = 150;
    const sX = entity.animX, sY = entity.animY;

    function step(timestamp) {
        if(!start) start = timestamp;
        let progress = (timestamp - start) / duration;
        if(progress > 1) progress = 1;
        
        entity.animX = sX + (entity.x - sX) * progress;
        entity.animY = sY + (entity.y - sY) * progress;
        draw();

        if(progress < 1) requestAnimationFrame(step);
        else animatePath(entity, path, callback);
    }
    requestAnimationFrame(step);
}

/* ===== ENEMY AI ===== */
function enemyTurn() {
    if(gameOver) return;
    let i = 0;
    function processNext() {
        if(i >= enemies.length) { playerTurn = true; draw(); return; }
        const e = enemies[i++];
        
        // Check vision BEFORE moving
        if(!player.hidden && canSee(e, player)) {
            showMessage("! DETECTED !");
            gameOver = true;
            setTimeout(() => alert("CAUGHT! Game Over."), 100);
            return;
        }

        // Logic
        let move = {x: 0, y: 0};
        if(e.target) {
            // Move toward investigation target
            move.x = Math.sign(e.target.x - e.x);
            move.y = Math.sign(e.target.y - e.y);
            if(e.x === e.target.x && e.y === e.target.y) e.target = null;
        } else {
            // Patrol
            if(!isValid(e.x + e.dir.x, e.y + e.dir.y)) {
                e.dir.x *= -1; e.dir.y *= -1;
            }
            move = e.dir;
        }

        if(isValid(e.x + move.x, e.y + move.y)) {
            animatePath(e, [{x: e.x + move.x, y: e.y + move.y}], processNext);
        } else {
            processNext();
        }
    }
    processNext();
}

function canSee(e, target) {
    const dx = Math.sign(e.dir.x || (target.x - e.x));
    const dy = Math.sign(e.dir.y || (target.y - e.y));
    
    for(let i=1; i<=e.vision; i++) {
        let vx = e.x + dx*i, vy = e.y + dy*i;
        if(!isValid(vx, vy)) break;
        if(vx === target.x && vy === target.y) return true;
    }
    return false;
}

function checkPlayerTile() {
    const tile = grid[player.y][player.x];
    player.hidden = (tile === HIDE);
    if(tile === NOISE) {
        showMessage("CLATTER! Enemies are investigating.");
        enemies.forEach(e => { if(Math.hypot(e.x-player.x, e.y-player.y) < 5) e.target = {x: player.x, y: player.y}; });
    }
    if(tile === EXIT) {
        showMessage("LEVEL COMPLETE!");
        gameOver = true;
        levelNumber++;
        setTimeout(startGame, 1000);
    }
}

/* ===== DRAWING ===== */
function draw() {
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    
    ctx.translate(camera.x, camera.y);
    ctx.scale(camera.scale, camera.scale);

    // Draw Grid
    for(let y=0; y<mapH; y++) {
        for(let x=0; x<mapW; x++) {
            let color = "#222";
            if(grid[y][x] === WALL) color = "#444";
            if(grid[y][x] === EXIT) color = "#0a0";
            if(grid[y][x] === NOISE) color = "#433";
            if(grid[y][x] === HIDE) color = "#111";
            
            ctx.fillStyle = color;
            ctx.fillRect(x*TILE, y*TILE, TILE-1, TILE-1);
        }
    }

    // Movable Highlights
    if(playerTurn && !gameOver) {
        ctx.fillStyle = "rgba(0, 170, 255, 0.15)";
        getMovableTiles().forEach(t => ctx.fillRect(t.x*TILE, t.y*TILE, TILE-1, TILE-1));
    }

    // Enemies
    enemies.forEach(e => {
        ctx.fillStyle = e.target ? "#f80" : "#f33";
        ctx.beginPath();
        ctx.arc(e.animX*TILE + TILE/2, e.animY*TILE + TILE/2, TILE/3, 0, Math.PI*2);
        ctx.fill();
        // Vision Direction
        ctx.strokeStyle = "rgba(255,0,0,0.3)";
        ctx.beginPath();
        ctx.moveTo(e.animX*TILE + TILE/2, e.animY*TILE + TILE/2);
        ctx.lineTo((e.animX + e.dir.x*2)*TILE + TILE/2, (e.animY + e.dir.y*2)*TILE + TILE/2);
        ctx.stroke();
    });

    // Player
    ctx.fillStyle = player.hidden ? "#55f" : "#0af";
    ctx.shadowBlur = player.hidden ? 0 : 10;
    ctx.shadowColor = "#0af";
    ctx.fillRect(player.animX*TILE + TILE/4, player.animY*TILE + TILE/4, TILE/2, TILE/2);
    ctx.shadowBlur = 0;

    requestAnimationFrame(() => {}); 
}

/* ===== INPUTS ===== */
canvas.addEventListener("pointerdown", e => {
    isDragging = true; lastX = e.clientX; lastY = e.clientY;
});

canvas.addEventListener("pointermove", e => {
    if(isDragging) {
        camera.x += e.clientX - lastX;
        camera.y += e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;
        draw();
    }
});

canvas.addEventListener("pointerup", e => {
    if(!isDragging) return;
    isDragging = false;
    // If it was a short tap, treat as move
    const rect = canvas.getBoundingClientRect();
    const worldX = (e.clientX - camera.x) / camera.scale;
    const worldY = (e.clientY - camera.y) / camera.scale;
    const tx = Math.floor(worldX / TILE);
    const ty = Math.floor(worldY / TILE);
    
    if(getMovableTiles().some(t => t.x === tx && t.y === ty)) movePlayerTo(tx, ty);
});

function playerWait() { if(playerTurn) { showMessage("Remaining silent..."); playerTurn = false; enemyTurn(); } }
function showMessage(m) {
    const div = document.createElement("div"); div.className = "message"; div.textContent = m;
    info.appendChild(div);
    setTimeout(() => div.remove(), 3000);
}
function backToMenu() { location.reload(); }

window.addEventListener("resize", () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; draw(); });

</script>
</body>
</html>
