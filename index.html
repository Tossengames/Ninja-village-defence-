<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Silent House: Shadow Protocol</title>

<style>
:root { --accent:#d4af37; --bg:#050505; --ink:#1a1a1a; }

body {
    margin:0;
    background:var(--bg);
    color:#eee;
    font-family: Palatino, Georgia, serif;
    overflow:hidden;
    touch-action:none;
}

canvas {
    display:block;
    margin:0 auto;
    image-rendering:pixelated;
    background:#000;
    cursor:crosshair;
}

.overlay-screen {
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.95);
    display:flex;
    flex-direction:column;
    justify-content:center;
    align-items:center;
    z-index:20;
}

.hidden { display:none !important; }

#toolbar {
    position:fixed;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    display:flex;
    gap:8px;
    z-index:10;
    background:rgba(20,20,20,0.9);
    padding:10px;
    border:1px solid var(--accent);
}

.tool-btn {
    width:55px;
    height:65px;
    background:#111;
    border:1px solid #444;
    color:#888;
    font-size:10px;
    display:flex;
    flex-direction:column;
    justify-content:center;
    align-items:center;
}

.tool-btn.active {
    border-color:var(--accent);
    color:var(--accent);
    box-shadow:0 0 10px rgba(212,175,55,0.6);
}

.btn-main {
    padding:10px 20px;
    background:#111;
    color:var(--accent);
    border:1px solid var(--accent);
    cursor:pointer;
}

input {
    width:40px;
    background:#111;
    border:1px solid #444;
    color:var(--accent);
    text-align:center;
}
</style>
</head>

<body>

<div id="menu" class="overlay-screen">
    <h1 style="color:var(--accent);letter-spacing:4px;">NINJA SELECTION</h1>
    Traps <input id="inpTraps" value="2" type="number">
    Rice <input id="inpRice" value="2" type="number">
    Bombs <input id="inpBombs" value="1" type="number">
    Map <input id="inpSize" value="12" type="number">
    <br><br>
    <button class="btn-main" onclick="initGame()">INFILTRATE</button>
</div>

<div id="gameOverScreen" class="overlay-screen hidden">
    <h1 style="color:#8b0000;">YOU ARE DEAD</h1>
    <button class="btn-main" onclick="location.reload()">RETRY</button>
</div>

<canvas id="game"></canvas>

<div id="toolbar" class="hidden">
    <div class="tool-btn active" id="btnMove" onclick="setMode('move')">Move</div>
    <div class="tool-btn" id="btnTrap" onclick="setMode('trap')">Trap (<span id="c-trap">0</span>)</div>
    <div class="tool-btn" id="btnRice" onclick="setMode('rice')">Rice (<span id="c-rice">0</span>)</div>
    <div class="tool-btn" id="btnBomb" onclick="setMode('bomb')">Bomb (<span id="c-bomb">0</span>)</div>
    <div class="tool-btn" onclick="playerWait()">Wait</div>
</div>

<script>
const TILE = 50;
const FLOOR=0, WALL=1, NOISE=2, EXIT=3, TRAP=6, RICE=7, BOMB=8, COIN=5;

let grid, player, enemies;
let selectMode='move', playerTurn=true, gameOver=false;
let inv={trap:0,rice:0,bomb:0};
let mapDim=12, shake=0;

const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');

function initGame(){
    inv.trap=+inpTraps.value;
    inv.rice=+inpRice.value;
    inv.bomb=+inpBombs.value;
    mapDim=+inpSize.value;

    menu.classList.add('hidden');
    toolbar.classList.remove('hidden');

    canvas.width=innerWidth;
    canvas.height=innerHeight;

    grid=[...Array(mapDim)].map((_,y)=>
        [...Array(mapDim)].map((_,x)=>
            x==0||y==0||x==mapDim-1||y==mapDim-1||Math.random()<0.18?WALL:FLOOR
        )
    );

    player={x:1,y:1,ax:1,ay:1,hidden:false};
    grid[mapDim-2][mapDim-2]=EXIT;

    enemies=[];
    for(let i=0;i<5;i++){
        let x,y;
        do{
            x=Math.floor(Math.random()*(mapDim-2))+1;
            y=Math.floor(Math.random()*(mapDim-2))+1;
        }while(grid[y][x]!=FLOOR);
        enemies.push({x,y,ax:x,ay:y,alive:true,dir:{x:1,y:0},range:4});
    }

    updateUI();
    requestAnimationFrame(loop);
}

function getAvailableMoves(){
    const res=[];
    [[1,0],[-1,0],[0,1],[0,-1]].forEach(d=>{
        let nx=player.x+d[0], ny=player.y+d[1];
        if(grid[ny]?.[nx]==FLOOR||grid[ny]?.[nx]==EXIT||grid[ny]?.[nx]==COIN)
            res.push({x:nx,y:ny});
    });
    return res;
}

function draw(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    let scale=Math.min(canvas.width/(mapDim*TILE),canvas.height/(mapDim*TILE));
    let ox=(canvas.width-mapDim*TILE*scale)/2+(Math.random()-0.5)*shake;
    let oy=(canvas.height-mapDim*TILE*scale)/2+(Math.random()-0.5)*shake;
    shake*=0.9;

    ctx.translate(ox,oy);
    ctx.scale(scale,scale);

    for(let y=0;y<mapDim;y++)for(let x=0;x<mapDim;x++){
        ctx.fillStyle='#111';
        ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
        if(grid[y][x]==WALL){
            ctx.fillStyle='#333';
            ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
        }
        if(grid[y][x]==EXIT){
            ctx.strokeStyle='#0f0';
            ctx.strokeRect(x*TILE+10,y*TILE+10,30,30);
        }
    }

    if(playerTurn && selectMode=='move'){
        ctx.strokeStyle='rgba(212,175,55,0.8)';
        ctx.lineWidth=3;
        getAvailableMoves().forEach(m=>{
            ctx.strokeRect(m.x*TILE+5,m.y*TILE+5,TILE-10,TILE-10);
        });
    }

    if(playerTurn && selectMode!='move'){
        ctx.strokeStyle='rgba(120,200,255,0.7)';
        ctx.lineWidth=2;
        for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
            let nx=player.x+dx, ny=player.y+dy;
            if(Math.hypot(dx,dy)<=1.5 && grid[ny]?.[nx]==FLOOR)
                ctx.strokeRect(nx*TILE+8,ny*TILE+8,TILE-16,TILE-16);
        }
    }

    ctx.fillStyle='#0af';
    ctx.beginPath();
    ctx.arc(player.ax*TILE+25,player.ay*TILE+25,12,0,7);
    ctx.fill();

    enemies.forEach(e=>{
        if(!e.alive)return;
        ctx.fillStyle='#f33';
        ctx.beginPath();
        ctx.arc(e.ax*TILE+25,e.ay*TILE+25,12,0,7);
        ctx.fill();
    });
}

function loop(){
    if(!gameOver) draw();
    requestAnimationFrame(loop);
}

canvas.addEventListener('pointerdown',e=>{
    if(!playerTurn||gameOver)return;

    let scale=Math.min(canvas.width/(mapDim*TILE),canvas.height/(mapDim*TILE));
    let ox=(canvas.width-mapDim*TILE*scale)/2;
    let oy=(canvas.height-mapDim*TILE*scale)/2;
    let tx=Math.floor(((e.clientX-ox)/scale)/TILE);
    let ty=Math.floor(((e.clientY-oy)/scale)/TILE);

    if(selectMode=='move'){
        if(getAvailableMoves().some(m=>m.x==tx&&m.y==ty)){
            playerTurn=false;
            animMove(player,tx,ty,()=>playerTurn=true);
        } else shake=10;
    }
    else if(grid[ty]?.[tx]==FLOOR){
        deployTool(tx,ty);
    }
});

function animMove(o,tx,ty,cb){
    let sx=o.ax, sy=o.ay, p=0;
    function step(){
        p+=0.2;
        o.ax=sx+(tx-sx)*p;
        o.ay=sy+(ty-sy)*p;
        if(p<1)requestAnimationFrame(step);
        else{ o.x=tx;o.y=ty;o.ax=tx;o.ay=ty;cb(); }
    }
    step();
}

function deployTool(x,y){
    if(inv[selectMode]<=0)return;
    grid[y][x]=selectMode=='trap'?TRAP:selectMode=='rice'?RICE:BOMB;
    inv[selectMode]--;
    if(inv[selectMode]<=0)setMode('move');
    updateUI();
    playerTurn=false;
    setTimeout(()=>playerTurn=true,200);
}

function updateUI(){
    cTrap.innerText=inv.trap;
    cRice.innerText=inv.rice;
    cBomb.innerText=inv.bomb;
}

function setMode(m){
    selectMode=m;
    document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
    document.getElementById('btn'+m.charAt(0).toUpperCase()+m.slice(1)).classList.add('active');
}

function playerWait(){
    if(playerTurn){
        playerTurn=false;
        setTimeout(()=>playerTurn=true,200);
    }
}
</script>
</body>
</html>