<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Silent House: Pro</title>
<style>
    body { margin: 0; background: #111; color: #eee; font-family: monospace; text-align: center; touch-action: none; overflow: hidden; }
    canvas { display: block; margin: 0 auto; background: #222; border: 2px solid #333; }
    #menu, #gameOverScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 20; display: flex; flex-direction: column; justify-content: center; align-items: center; }
    input { background: #222; color: #0af; border: 1px solid #444; padding: 8px; width: 60px; text-align: center; margin: 5px; font-size: 18px; }
    button { padding: 15px 30px; margin: 10px; background: #333; color: #eee; border: 1px solid #555; cursor: pointer; font-family: monospace; font-size: 16px; }
    button:active { background: #0af; color: #000; }
    .hidden { display: none !important; }
    #ui-layer { position: fixed; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; }
    #info { margin-top: 10px; align-self: center; width: 90%; }
    #controls { margin-bottom: 20px; align-self: center; pointer-events: auto; }
    .message { background: rgba(0,0,0,0.8); padding: 5px 10px; border: 1px solid #444; margin-bottom: 2px; font-size: 14px; }
</style>
</head>
<body>

<div id="menu">
    <h2 style="color:#0af; letter-spacing: 4px;">SILENT HOUSE</h2>
    <p>Mission Level: <span id="levelText">1</span></p>
    <div>Map: <input type="number" id="inpW" value="12"> x <input type="number" id="inpH" value="12"></div>
    <div>Enemies: <input type="number" id="inpE" value="4"></div>
    <button onclick="startGame()">START INFILTRATION</button>
</div>

<div id="gameOverScreen" class="hidden">
    <h1 id="statusTitle" style="color:#f00;">DETECTED</h1>
    <button onclick="startGame()">RETRY MISSION</button>
    <button onclick="toggleMenu(true)">MAIN MENU</button>
</div>

<div id="ui-layer">
    <div id="info"></div>
    <div id="controls" class="hidden">
        <button onclick="playerWait()">WAIT</button>
    </div>
</div>

<canvas id="game" class="hidden"></canvas>

<script>
const TILE = 48;
const FLOOR=0, WALL=1, NOISE=2, EXIT=3, HIDE=4;
let levelNumber = 1, grid, player, enemies, gameOver = false, playerTurn = true;
let mapW, mapH, enemyCount;

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function toggleMenu(show) {
    document.getElementById("menu").classList.toggle("hidden", !show);
    document.getElementById("gameOverScreen").classList.add("hidden");
    canvas.classList.toggle("hidden", show);
    document.getElementById("controls").classList.toggle("hidden", show);
}

function startGame() {
    mapW = parseInt(document.getElementById("inpW").value);
    mapH = parseInt(document.getElementById("inpH").value);
    enemyCount = parseInt(document.getElementById("inpE").value);
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    toggleMenu(false);
    generateLevel();
}

function generateLevel() {
    gameOver = false; playerTurn = true;
    grid = Array.from({length: mapH}, (_, y) => Array.from({length: mapW}, (_, x) => 
        (x===0 || y===0 || x===mapW-1 || y===mapH-1) ? WALL : Math.random() < 0.18 ? WALL : FLOOR
    ));

    let ex, ey; 
    do { ex = Math.floor(Math.random()*(mapW-2))+1; ey = Math.floor(Math.random()*(mapH-2))+1; } while(grid[ey][ex] !== FLOOR);
    grid[ey][ex] = EXIT;

    let px, py; 
    do { px = Math.floor(Math.random()*(mapW-2))+1; py = Math.floor(Math.random()*(mapH-2))+1; } 
    while(grid[py][px] !== FLOOR || Math.hypot(px-ex, py-ey) < 6);
    player = { x: px, y: py, animX: px, animY: py, hidden: false };

    for(let i=0; i<3; i++) placeRandom(NOISE);
    for(let i=0; i<3; i++) placeRandom(HIDE);

    enemies = [];
    for(let i=0; i<enemyCount; i++) {
        let enX, enY; 
        do { enX = Math.floor(Math.random()*(mapW-2))+1; enY = Math.floor(Math.random()*(mapH-2))+1; }
        while(grid[enY][enX] !== FLOOR || Math.hypot(enX-px, enY-py) < 4);
        enemies.push({ x: enX, y: enY, animX: enX, animY: enY, dir: {x:1, y:0}, target: null, visionRange: 4, mark: null });
    }
    draw();
}

function placeRandom(type) {
    let x, y; do { x = Math.floor(Math.random()*(mapW-2))+1; y = Math.floor(Math.random()*(mapH-2))+1; } while(grid[y][x] !== FLOOR);
    grid[y][x] = type;
}

function isValid(x, y) { return x >= 0 && y >= 0 && x < mapW && y < mapH && grid[y][x] !== WALL; }

/* ===== PATHFINDING (BFS for simplicity/speed) ===== */
function findPath(startX, startY, targetX, targetY) {
    let queue = [[{x: startX, y: startY}]];
    let visited = new Set([startX + ',' + startY]);
    while(queue.length > 0) {
        let path = queue.shift();
        let curr = path[path.length - 1];
        if(curr.x === targetX && curr.y === targetY) return path;
        for(let d of [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}]) {
            let next = {x: curr.x + d.x, y: curr.y + d.y};
            if(isValid(next.x, next.y) && !visited.has(next.x + ',' + next.y)) {
                visited.add(next.x + ',' + next.y);
                queue.push([...path, next]);
            }
        }
    }
    return null;
}

canvas.addEventListener("pointerdown", e => {
    if(!playerTurn || gameOver) return;
    const scale = Math.min(canvas.width/(mapW*TILE), canvas.height/(mapH*TILE));
    const ox = (canvas.width - mapW*TILE*scale)/2, oy = (canvas.height - mapH*TILE*scale)/2;
    const tx = Math.floor(((e.clientX - ox) / scale) / TILE), ty = Math.floor(((e.clientY - oy) / scale) / TILE);

    const movable = [];
    for(let dx=-2; dx<=2; dx++) for(let dy=-2; dy<=2; dy++) {
        if(Math.abs(dx) + Math.abs(dy) > 2 || (dx===0 && dy===0)) continue;
        if(isValid(player.x + dx, player.y + dy) && isValid(player.x + Math.sign(dx), player.y + Math.sign(dy))) movable.push({x: player.x + dx, y: player.y + dy});
    }

    if(movable.some(t => t.x === tx && t.y === ty)) {
        playerTurn = false;
        animateMove(player, tx, ty, () => { checkTile(); if(!gameOver) enemyTurn(); });
    }
});

function animateMove(ent, tx, ty, cb) {
    const startX = ent.animX, startY = ent.animY;
    let progress = 0;
    if(ent !== player) { ent.dir = {x: Math.sign(tx - ent.x), y: Math.sign(ty - ent.y)}; }

    function step() {
        progress += 0.15;
        ent.animX = startX + (tx - startX) * progress;
        ent.animY = startY + (ty - startY) * progress;
        if(ent === player && !player.hidden) {
            for(let e of enemies) if(isInVision(e, ent.animX, ent.animY)) { gameOver=true; draw(); setTimeout(() => document.getElementById("gameOverScreen").classList.remove("hidden"), 300); return; }
        }
        draw();
        if(progress < 1) requestAnimationFrame(step);
        else { ent.x = tx; ent.y = ty; ent.animX = tx; ent.animY = ty; cb(); }
    }
    step();
}

async function enemyTurn() {
    if(gameOver) return;
    for(let e of enemies) {
        await new Promise(r => setTimeout(r, 200));
        
        // If no target, pick a random floor tile to "patrol"
        if(!e.target) {
            let rx, ry; do { rx = Math.floor(Math.random()*mapW); ry = Math.floor(Math.random()*mapH); } while(!isValid(rx, ry));
            e.target = {x: rx, y: ry}; e.mark = null;
        }

        let path = findPath(e.x, e.y, e.target.x, e.target.y);
        if(path && path.length > 1) {
            let next = path[1];
            // Don't walk into other enemies
            if(!enemies.some(other => other !== e && other.x === next.x && other.y === next.y)) {
                await new Promise(r => animateMove(e, next.x, next.y, r));
            }
        } else { e.target = null; } // Target reached or unreachable

        if(!player.hidden && isInVision(e, player.x, player.y)) { gameOver=true; draw(); setTimeout(() => document.getElementById("gameOverScreen").classList.remove("hidden"), 300); return; }
    }
    playerTurn = true; draw();
}

function isInVision(e, px, py) {
    const dx = px - e.x, dy = py - e.y;
    const dist = Math.hypot(dx, dy);
    if(dist > e.visionRange) return false;
    
    // Check Angle
    const angleToPlayer = Math.atan2(dy, dx);
    const enemyAngle = Math.atan2(e.dir.y, e.dir.x);
    let diff = Math.abs(angleToPlayer - enemyAngle);
    while (diff > Math.PI) diff -= Math.PI * 2;
    if(Math.abs(diff) > 0.7) return false;

    // RAYCAST: Check if wall is in between
    let steps = dist * 2;
    for(let i=1; i<=steps; i++) {
        let checkX = e.x + (dx * (i/steps));
        let checkY = e.y + (dy * (i/steps));
        if(grid[Math.floor(checkY)][Math.floor(checkX)] === WALL) return false;
    }
    return true;
}

function draw() {
    const scale = Math.min(canvas.width/(mapW*TILE), canvas.height/(mapH*TILE));
    const ox = (canvas.width - mapW*TILE*scale)/2, oy = (canvas.height - mapH*TILE*scale)/2;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.translate(ox, oy); ctx.scale(scale, scale);

    for(let y=0; y<mapH; y++) for(let x=0; x<mapW; x++) {
        ctx.fillStyle = grid[y][x] === WALL ? "#444" : "#111";
        ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        ctx.strokeStyle = "#000"; ctx.strokeRect(x*TILE, y*TILE, TILE, TILE);
        if(grid[y][x] === EXIT) { ctx.fillStyle="#0a0"; ctx.fillRect(x*TILE+8, y*TILE+8, TILE-16, TILE-16); }
        if(grid[y][x] === NOISE) { ctx.strokeStyle="#f80"; ctx.strokeRect(x*TILE+10, y*TILE+10, TILE-20, TILE-20); }
        if(grid[y][x] === HIDE) { ctx.fillStyle="#000"; ctx.strokeRect(x*TILE+5, y*TILE+5, TILE-10, TILE-10); }
    }

    enemies.forEach(e => {
        ctx.fillStyle = "rgba(255,0,0,0.15)";
        ctx.beginPath(); ctx.moveTo(e.animX*TILE + TILE/2, e.animY*TILE + TILE/2);
        const ang = Math.atan2(e.dir.y, e.dir.x);
        ctx.arc(e.animX*TILE + TILE/2, e.animY*TILE + TILE/2, e.visionRange * TILE, ang-0.6, ang+0.6);
        ctx.fill();

        ctx.fillStyle = "#f33"; ctx.fillRect(e.animX*TILE+12, e.animY*TILE+12, 24, 24);
        if(e.mark) { ctx.fillStyle="#fff"; ctx.fillText(e.mark, e.animX*TILE+18, e.animY*TILE+8); }
    });

    ctx.fillStyle = player.hidden ? "#00a" : "#0af";
    ctx.fillRect(player.animX*TILE+12, player.animY*TILE+12, 24, 24);
}

function checkTile() {
    const t = grid[player.y][player.x];
    player.hidden = (t === HIDE);
    if(t === NOISE) {
        enemies.forEach(e => { if(Math.hypot(e.x-player.x, e.y-player.y) < 7) { e.target = {x: player.x, y: player.y}; e.mark = "?"; }});
    }
    if(t === EXIT) { levelNumber++; generateLevel(); }
}

function playerWait() { if(playerTurn) { playerTurn = false; enemyTurn(); } }
</script>
</body>
</html>
