<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Silent House: Advanced</title>
<style>
body {
  margin:0;
  background:#111;
  color:#eee;
  font-family: monospace;
  text-align:center;
  touch-action:none;
  overscroll-behavior:none;
}
canvas {
  display:block;
  margin:0 auto;
  background:#222;
  border:2px solid #555;
}
button {
  padding:10px 16px;
  margin:5px;
  background:#333;
  color:#eee;
  border:1px solid #666;
}
.hidden { display:none; }
#controls button {
  width:60px;
  height:60px;
  font-size:22px;
}
#info {
  min-height:40px;
  position:relative;
}
.message {
  position:absolute;
  top:0;
  left:50%;
  transform:translateX(-50%);
  background:rgba(0,0,0,0.8);
  padding:4px 8px;
  border-radius:4px;
  color:#fff;
  font-size:14px;
  animation:fade 2s forwards;
}
@keyframes fade {
  0%{opacity:1;}
  100%{opacity:0;}
}
</style>
</head>
<body>

<h2>Silent House: Advanced</h2>

<div id="menu">
  <p>Turn-based ninja puzzle</p>
  <p>Level: <span id="levelText">1</span></p>
  <button onclick="changeLevel(-1)">−</button>
  <button onclick="changeLevel(1)">+</button><br><br>
  <button onclick="startGame()">START</button>
</div>

<canvas id="game" width="320" height="320" class="hidden"></canvas>

<div id="controls" class="hidden">
  <button onclick="playerWait()">Wait</button>
</div>

<p id="info"></p>
<button id="backBtn" class="hidden" onclick="backToMenu()">BACK</button>

<script>
/* ===== CONFIG ===== */
const SIZE=10, TILE=32;
const FLOOR=0, WALL=1, NOISE=2, EXIT=3, HIDE=4;

let levelNumber=1, grid, player, enemies, gameOver, playerTurn=true;
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
const info=document.getElementById("info");

/* ===== MENU ===== */
function changeLevel(v){ levelNumber=Math.max(1,levelNumber+v); levelText.textContent=levelNumber;}
function startGame(){
  menu.classList.add("hidden");
  game.classList.remove("hidden");
  controls.classList.remove("hidden");
  backBtn.classList.remove("hidden");
  generateLevel();
}
function backToMenu(){
  menu.classList.remove("hidden");
  game.classList.add("hidden");
  controls.classList.add("hidden");
  backBtn.classList.add("hidden");
  clearMessages();
}

/* ===== LEVEL GENERATION ===== */
function generateLevel(){
  gameOver=false;
  playerTurn=true;
  grid=Array.from({length:SIZE},(_,y)=>
    Array.from({length:SIZE},(_,x)=>
      (x===0||y===0||x===SIZE-1||y===SIZE-1)?WALL:
      Math.random()<0.15?WALL:FLOOR
    )
  );
  player={x:1,y:1,hidden:false,px:1,py:1};
  grid[SIZE-2][SIZE-2]=EXIT;

  for(let i=0;i<levelNumber+1;i++) placeRandom(NOISE);
  for(let i=0;i<Math.max(1,Math.floor(levelNumber/2));i++) placeRandom(HIDE);

  enemies=[];
  const count=Math.min(1+Math.floor(levelNumber/2),6);
  for(let i=0;i<count;i++) spawnEnemy();

  showMessage(`Level ${levelNumber} • Enemies ${count}`);
  draw();
}

function placeRandom(type){
  let x,y;
  do{x=Math.floor(Math.random()*SIZE);y=Math.floor(Math.random()*SIZE);}while(grid[y][x]!==FLOOR||(x===1&&y===1));
  grid[y][x]=type;
}

function spawnEnemy(){
  let x,y;
  do{x=Math.floor(Math.random()*SIZE);y=Math.floor(Math.random()*SIZE);}while(grid[y][x]!==FLOOR);
  enemies.push({x,y,dir:[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}][Math.floor(Math.random()*4)],target:null,px:x,py:y});
}

/* ===== MESSAGES ===== */
function showMessage(text){
  const msg=document.createElement("div");
  msg.className="message"; msg.textContent=text;
  info.appendChild(msg);
  setTimeout(()=>{msg.remove();},2000);
}
function clearMessages(){info.innerHTML="";}

/* ===== PLAYER TURN ===== */
function playerWait(){
  if(!playerTurn||gameOver)return;
  showMessage("You wait...");
  playerTurn=false;
  setTimeout(enemyTurn,300);
}

function getMovableTiles(){
  const tiles=[];
  for(let dx=-2;dx<=2;dx++)for(let dy=-2;dy<=2;dy++){
    const nx=player.x+dx, ny=player.y+dy;
    if(nx>=0&&ny>=0&&nx<SIZE&&ny<SIZE){
      if(grid[ny][nx]!==WALL && Math.abs(dx)+Math.abs(dy)<=2 && !(dx===0 && dy===0)) tiles.push({x:nx,y:ny});
    }
  }
  return tiles;
}

/* ===== PLAYER MOVE CLICK ===== */
canvas.addEventListener("click",e=>{
  if(!playerTurn||gameOver)return;
  const rect=canvas.getBoundingClientRect();
  const mx=Math.floor((e.clientX-rect.left)/TILE);
  const my=Math.floor((e.clientY-rect.top)/TILE);
  const tiles=getMovableTiles();
  const target=tiles.find(t=>t.x===mx&&t.y===my);
  if(target) movePlayerTo(target.x,target.y);
});

/* ===== PLAYER MOVE LOGIC ===== */
function movePlayerTo(tx,ty){
  playerTurn=false;
  showMessage("Moving...");
  const dx=tx-player.x, dy=ty-player.y;
  const steps=Math.max(Math.abs(dx),Math.abs(dy));
  const path=[];
  for(let i=1;i<=steps;i++){
    path.push({x:player.x + Math.round(dx*i/steps), y:player.y + Math.round(dy*i/steps)});
  }
  animateMovement(path,()=>{postPlayerMove();});
}

function animateMovement(path,callback){
  if(path.length===0){ callback(); return; }
  const p=path.shift();
  player.px=player.x*TILE + (p.x-player.x)*TILE;
  player.py=player.y*TILE + (p.y-player.y)*TILE;
  player.x=p.x; player.y=p.y;
  draw();
  setTimeout(()=>animateMovement(path,callback),150);
}

function postPlayerMove(){
  player.hidden=grid[player.y][player.x]===HIDE;
  if(grid[player.y][player.x]===NOISE){
    enemies.forEach(e=>e.target={x:player.x,y:player.y});
    showMessage("Noise! Guards alerted");
  }
  if(grid[player.y][player.x]===EXIT){
    showMessage("Escaped!");
    gameOver=true;
    levelNumber++;
    setTimeout(startGame,1000);
    return;
  }
  setTimeout(enemyTurn,300);
}

/* ===== ENEMY TURN ===== */
function enemyTurn(){
  if(gameOver)return;
  showMessage("Enemy Turn...");
  const moves=[];
  enemies.forEach(e=>{
    if(!player.hidden && canSee(e)) { showMessage("You were seen!"); gameOver=true; return; }
    if(e.target) moves.push({enemy:e,type:"target"});
    else moves.push({enemy:e,type:"patrol"});
  });
  if(gameOver)return;
  animateEnemies(moves,()=>{playerTurn=true; showMessage("Your Turn"); draw();});
}

function animateEnemies(list,callback){
  if(list.length===0){ callback(); return; }
  const m=list.shift();
  const e=m.enemy;
  let tx=e.x, ty=e.y;
  if(m.type==="target"){ tx=e.target.x; ty=e.target.y; }
  else{ 
    const nx=e.x+e.dir.x, ny=e.y+e.dir.y;
    if(nx>=0&&ny>=0&&nx<SIZE&&ny<SIZE&&grid[ny][nx]!==WALL){tx=nx; ty=ny;} else { e.dir.x*=-1; e.dir.y*=-1; tx=e.x+e.dir.x; ty=e.y+e.dir.y;}
  }
  const path=[{x:tx,y:ty}];
  animateEnemyMovement(e,path,()=>{animateEnemies(list,callback);});
}

function animateEnemyMovement(e,path,callback){
  if(path.length===0){ if(e.target && e.x===e.target.x && e.y===e.target.y) e.target=null; callback(); return; }
  const p=path.shift();
  e.px=e.x*TILE + (p.x-e.x)*TILE;
  e.py=e.y*TILE + (p.y-e.y)*TILE;
  e.x=p.x; e.y=p.y;
  draw();
  setTimeout(()=>animateEnemyMovement(e,path,callback),200);
}

/* ===== VISION CHECK ===== */
function canSee(e){
  const dx=player.x-e.x, dy=player.y-e.y;
  if(Math.abs(dx)+Math.abs(dy)>4) return false;
  if(dx!==0&&dy!==0) return false;
  const sx=Math.sign(dx), sy=Math.sign(dy);
  let x=e.x+sx, y=e.y+sy;
  while(x!==player.x||y!==player.y){
    if(grid[y][x]===WALL) return false;
    x+=sx; y+=sy;
  }
  return true;
}

/* ===== DRAW ===== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // tiles
  for(let y=0;y<SIZE;y++)for(let x=0;x<SIZE;x++){
    ctx.fillStyle=
      grid[y][x]===WALL?"#555":
      grid[y][x]===HIDE?"#000":
      grid[y][x]===NOISE?"#aa0":
      grid[y][x]===EXIT?"#0a0":"#222";
    ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
  }

  // highlight moves
  if(playerTurn){
    getMovableTiles().forEach(t=>{
      ctx.fillStyle="rgba(0,150,255,0.3)";
      ctx.fillRect(t.x*TILE,t.y*TILE,TILE,TILE);
    });
  }

  // enemy vision cones
  enemies.forEach(e=>{
    for(let i=1;i<=4;i++){
      const x=e.x + e.dir.x*i, y=e.y + e.dir.y*i;
      if(x<0||y<0||x>=SIZE||y>=SIZE||grid[y][x]===WALL) break;
      ctx.fillStyle="rgba(255,0,0,0.2)";
      ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
    }
  });

  // player
  ctx.fillStyle=player.hidden?"#00a":"#0af";
  const px=player.px!==undefined?player.px:TILE*player.x;
  const py=player.py!==undefined?player.py:TILE*player.y;
  ctx.fillRect(px+8,py+8,16,16);

  // enemies
  ctx.fillStyle="#f00";
  enemies.forEach(e=>{
    const ex=e.px!==undefined?e.px:TILE*e.x;
    const ey=e.py!==undefined?e.py:TILE*e.y;
    ctx.fillRect(ex+8,ey+8,16,16);
  });
}

/* ===== TOUCH SWIPE ===== */
let sx=0, sy=0;
canvas.addEventListener("touchstart",e=>{
  const t=e.touches[0]; sx=t.clientX; sy=t.clientY; e.preventDefault();
});
canvas.addEventListener("touchend",e=>{
  const t=e.changedTouches[0]; const dx=t.clientX-sx, dy=t.clientY-sy;
  if(!playerTurn||gameOver)return;
  const tiles=getMovableTiles();
  if(Math.abs(dx)>Math.abs(dy)){
    const target=dx>30?tiles.find(t=>t.x>player.x):tiles.find(t=>t.x<player.x);
    if(target) movePlayerTo(target.x,target.y);
  } else{
    const target=dy>30?tiles.find(t=>t.y>player.y):tiles.find(t=>t.y<player.y);
    if(target) movePlayerTo(target.x,target.y);
  }
  e.preventDefault();
});

</script>
</body>
</html>