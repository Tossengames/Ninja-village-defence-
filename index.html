<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Silent House: Protocol</title>
<style>
    :root { --accent: #0af; --bg: #0a0a0f; }
    body { margin: 0; background: var(--bg); color: #eee; font-family: 'Courier New', monospace; overflow: hidden; touch-action: none; }
    canvas { display: block; margin: 0 auto; background: #000; cursor: crosshair; }
    
    .overlay-screen { position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 20; }
    .hidden { display: none !important; }

    .setting-group { margin: 10px; display: flex; align-items: center; gap: 10px; font-size: 16px; }
    input { background: #111; color: var(--accent); border: 1px solid #444; padding: 5px; width: 50px; text-align: center; font-family: inherit; }
    
    #toolbar { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; z-index: 10; background: rgba(0,0,0,0.8); padding: 10px; border: 1px solid #333; border-radius: 8px; pointer-events: auto; }
    .tool-btn { width: 55px; height: 65px; background: #111; border: 1px solid #444; color: #666; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 11px; cursor: pointer; border-radius: 4px; }
    .tool-btn.active { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 8px var(--accent); }
    .tool-btn b { font-size: 18px; }

    .btn-main { padding: 12px 30px; background: transparent; color: var(--accent); border: 2px solid var(--accent); cursor: pointer; font-weight: bold; margin-top: 20px; }
    .btn-main:hover { background: var(--accent); color: #000; }
    #msgLog { position: fixed; top: 10px; width: 100%; text-align: center; pointer-events: none; z-index: 5; }
    .log-msg { color: var(--accent); font-size: 13px; text-shadow: 0 0 5px #000; font-weight: bold;}
</style>
</head>
<body>

<div id="menu" class="overlay-screen">
    <h1 style="color:var(--accent); letter-spacing: 5px;">LOADOUT SELECTION</h1>
    <div class="setting-group">Traps: <input type="number" id="inpTraps" value="2"> Rice: <input type="number" id="inpRice" value="2"></div>
    <div class="setting-group">Bombs: <input type="number" id="inpBombs" value="2"> Crackers: <input type="number" id="inpCracks" value="2"></div>
    <hr style="width:200px; border:0; border-top:1px solid #333">
    <div class="setting-group">Guards: <input type="number" id="inpE" value="5"> Map: <input type="number" id="inpSize" value="12"></div>
    <button class="btn-main" onclick="initGame()">START MISSION</button>
</div>

<div id="resultScreen" class="overlay-screen hidden">
    <h2 id="winTitle" style="color:var(--accent)">MISSION SUCCESS</h2>
    <div id="stats" style="margin: 15px; text-align: left; line-height: 1.6;"></div>
    <button class="btn-main" onclick="showLoadout()">NEXT FLOOR</button>
</div>

<div id="gameOverScreen" class="overlay-screen hidden">
    <h1 style="color:#f00;">DETECTED</h1>
    <button class="btn-main" style="color:#f00; border-color:#f00" onclick="showLoadout()">RETRY</button>
</div>

<div id="msgLog"></div>

<div id="toolbar" class="hidden">
    <div class="tool-btn active" id="btnMove" onclick="setMode('move')"><b>üë§</b>Move</div>
    <div class="tool-btn" id="btnTrap" onclick="setMode('trap')"><b>ü™§</b><span id="c-trap">0</span></div>
    <div class="tool-btn" id="btnRice" onclick="setMode('rice')"><b>üçô</b><span id="c-rice">0</span></div>
    <div class="tool-btn" id="btnBomb" onclick="setMode('bomb')"><b>üí£</b><span id="c-bomb">0</span></div>
    <div class="tool-btn" id="btnCrack" onclick="setMode('crack')"><b>üéá</b><span id="c-crack">0</span></div>
    <div class="tool-btn" onclick="playerWait()"><b>‚è≥</b>Wait</div>
</div>

<canvas id="game"></canvas>

<script>
const TILE = 50;
const FLOOR=0, WALL=1, NOISE=2, EXIT=3, HIDE=4, COIN=5, TRAP=6, RICE=7, BOMB=8, CRACK=9, CHEST=10;

let grid, player, enemies, particles = [], activeTools = [];
let selectMode = 'move', gameOver = false, playerTurn = true;
let gameStats = { turns: 0, kills: 0, coins: 0 };
let inv = { trap: 0, rice: 0, bomb: 0, crack: 0 };
let mapDim = 12, shake = 0;

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const DIALOGUE = ["My feet hurt...", "I'm so hungry.", "Was that a rat?", "Did I leave the stove on?", "This job is boring.", "Wish I was at the tavern.", "Night shifts suck.", "I need a raise."];

function showLoadout() {
    document.querySelectorAll('.overlay-screen').forEach(s => s.classList.add('hidden'));
    document.getElementById('menu').classList.remove('hidden');
    document.getElementById('toolbar').classList.add('hidden');
}

function initGame() {
    inv.trap = parseInt(document.getElementById('inpTraps').value);
    inv.rice = parseInt(document.getElementById('inpRice').value);
    inv.bomb = parseInt(document.getElementById('inpBombs').value);
    inv.crack = parseInt(document.getElementById('inpCracks').value);
    mapDim = parseInt(document.getElementById('inpSize').value);
    
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('toolbar').classList.remove('hidden');
    generateLevel();
}

function generateLevel() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gameStats = { turns: 0, kills: 0, coins: 0 };
    activeTools = []; particles = [];
    
    grid = Array.from({length: mapDim}, (_, y) => Array.from({length: mapDim}, (_, x) => 
        (x==0 || y==0 || x==mapDim-1 || y==mapDim-1) ? WALL : Math.random() < 0.18 ? WALL : FLOOR
    ));

    player = { x: 1, y: 1, ax: 1, ay: 1, hidden: false };
    grid[1][1] = FLOOR;
    grid[mapDim-2][mapDim-2] = EXIT;
    
    placeRandom(CHEST, 2);
    placeRandom(COIN, 4);
    placeRandom(HIDE, 3);
    placeRandom(NOISE, 3); // These are the invisible noise traps

    enemies = [];
    let count = parseInt(document.getElementById('inpE').value);
    for(let i=0; i<count; i++) {
        let ex, ey; do { ex = Math.floor(Math.random()*(mapDim-2))+1; ey = Math.floor(Math.random()*(mapDim-2))+1; }
        while(grid[ey][ex] !== FLOOR || Math.hypot(ex-1, ey-1) < 5);
        enemies.push({ x: ex, y: ey, ax: ex, ay: ey, dir: {x:1, y:0}, target: null, alive: true, range: 4, status: "Patrolling", bubble: "" });
    }

    playerTurn = true; gameOver = false;
    updateUI();
    requestAnimationFrame(gameLoop);
}

function placeRandom(type, count) {
    for(let i=0; i<count; i++) {
        let x, y; do { x = Math.floor(Math.random()*(mapDim-2))+1; y = Math.floor(Math.random()*(mapDim-2))+1; } while(grid[y][x] !== FLOOR);
        grid[y][x] = type;
    }
}

canvas.addEventListener('pointerdown', e => {
    if(!playerTurn || gameOver) return;
    const scale = Math.min(canvas.width/(mapDim*TILE), canvas.height/(mapDim*TILE));
    const ox = (canvas.width - mapDim*TILE*scale)/2, oy = (canvas.height - mapDim*TILE*scale)/2;
    const tx = Math.floor(((e.clientX - ox)/scale)/TILE), ty = Math.floor(((e.clientY - oy)/scale)/TILE);

    if (tx < 0 || ty < 0 || tx >= mapDim || ty >= mapDim) return;
    const dist = Math.hypot(tx-player.x, ty-player.y);
    
    if(selectMode === 'move' && dist > 0 && dist < 2.5) {
        playerTurn = false; gameStats.turns++;
        animMove(player, tx, ty, () => { checkTile(); endTurn(); });
    } else if(selectMode !== 'move' && dist < 1.5 && grid[ty][tx] === FLOOR) {
        deployTool(tx, ty);
    }
});

function deployTool(tx, ty) {
    if(selectMode === 'trap' && inv.trap > 0) { grid[ty][tx] = TRAP; inv.trap--; log("Trap Set."); }
    else if(selectMode === 'rice' && inv.rice > 0) { grid[ty][tx] = RICE; inv.rice--; log("Rice Set."); }
    else if(selectMode === 'bomb' && inv.bomb > 0) { grid[ty][tx] = BOMB; inv.bomb--; activeTools.push({x:tx,y:ty,type:'bomb',t:2}); log("Bomb: 2 Turns."); }
    else if(selectMode === 'crack' && inv.crack > 0) { grid[ty][tx] = CRACK; inv.crack--; activeTools.push({x:tx,y:ty,type:'crack',t:2,u:2}); log("Cracker: 2 Hits."); }
    else return;
    updateUI(); playerTurn = false; endTurn();
}

async function endTurn() {
    for(let e of enemies.filter(en => en.alive)) {
        await new Promise(r => setTimeout(r, 100));
        
        // Trap check
        if(grid[e.y][e.x] === TRAP || grid[e.y][e.x] === RICE) {
            let wasRice = grid[e.y][e.x] === RICE;
            e.alive = false; grid[e.y][e.x] = FLOOR; gameStats.kills++;
            spawnPart(e.x, e.y, wasRice ? "#fff" : "#f00", 30); shake=15;
            
            if(wasRice) { // If rice is eaten, others forget it
                enemies.forEach(other => { if(other.target && grid[other.target.y]?.[other.target.x] !== RICE) { other.target = null; other.status = "Returning"; }});
            }
            continue;
        }

        // Behavior
        if(e.target && grid[e.target.y][e.target.x] === WALL) { e.target = null; e.status = "Patrolling"; }
        
        let nx = e.x, ny = e.y;
        if(e.target) {
            e.status = "Searching...";
            if(nx < e.target.x) nx++; else if(nx > e.target.x) nx--;
            else if(ny < e.target.y) ny++; else if(ny > e.target.y) ny--;
            if(nx == e.target.x && ny == e.target.y) e.target = null;
        } else {
            e.status = "Patrolling";
            e.bubble = Math.random() < 0.1 ? DIALOGUE[Math.floor(Math.random()*DIALOGUE.length)] : "";
            const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
            const d = dirs[Math.floor(Math.random()*4)];
            if(grid[e.y+d.y]?.[e.x+d.x] === FLOOR) { nx+=d.x; ny+=d.y; }
        }
        
        await new Promise(r => animMove(e, nx, ny, r));
        if(!player.hidden && hasLineOfSight(e, player.x, player.y)) { triggerDeath(); return; }
    }

    activeTools.forEach((tool, i) => {
        tool.t--;
        if(tool.t <= 0) {
            if(tool.type === 'bomb') {
                spawnPart(tool.x, tool.y, "#f50", 60); shake=25;
                grid[tool.y][tool.x] = FLOOR;
                enemies.forEach(en => { if(Math.hypot(en.x-tool.x, en.y-tool.y) < 8) { en.target = {x:tool.x, y:tool.y}; en.status = "INVESTIGATING!"; }});
                activeTools.splice(i, 1);
            } else {
                spawnPart(tool.x, tool.y, "#fff", 20);
                enemies.forEach(en => { if(Math.hypot(en.x-tool.x, en.y-tool.y) < 6) { en.target = {x:tool.x, y:tool.y}; en.status = "WHAT WAS THAT?"; }});
                tool.u--; if(tool.u <= 0) { grid[tool.y][tool.x] = FLOOR; activeTools.splice(i, 1); } else tool.t = 2;
            }
        }
    });
    playerTurn = true; setMode('move');
}

function checkTile() {
    const t = grid[player.y][player.x];
    player.hidden = (t === HIDE);
    if(t === EXIT) win();
    if(t === COIN) { gameStats.coins++; grid[player.y][player.x] = FLOOR; log("Coin Collected."); }
    if(t === NOISE) { 
        log("!! YOU STEPPED ON A BELL !!"); 
        shake = 10;
        enemies.forEach(e => { if(e.alive) { e.target = {x:player.x, y:player.y}; e.status = "HEARD SOMETHING!"; }}); 
    }
    if(t === CHEST) {
        grid[player.y][player.x] = FLOOR;
        if(Math.random() < 0.6) {
            const items = ['trap','rice','bomb','crack'];
            inv[items[Math.floor(Math.random()*4)]] += 2; log("Chest Looted!");
        } else { log("Chest Alarm triggered!"); enemies.forEach(e => {e.target = {x:player.x, y:player.y}; e.status="ALARM!!";}); shake=15; }
        updateUI();
    }
}

function gameLoop() {
    if(gameOver) return;
    draw();
    requestAnimationFrame(gameLoop);
}

function draw() {
    const scale = Math.min(canvas.width/(mapDim*TILE), canvas.height/(mapDim*TILE));
    const ox = (canvas.width - mapDim*TILE*scale)/2 + (Math.random()-0.5)*shake;
    const oy = (canvas.height - mapDim*TILE*scale)/2 + (Math.random()-0.5)*shake;
    shake *= 0.9;

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.translate(ox, oy); ctx.scale(scale, scale);

    // Tiles
    for(let y=0; y<mapDim; y++) for(let x=0; x<mapDim; x++) {
        ctx.fillStyle = grid[y][x] === WALL ? "#1a1a24" : "#08080c";
        ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        ctx.strokeStyle = "#111"; ctx.strokeRect(x*TILE, y*TILE, TILE, TILE);

        // Render visible items
        if(grid[y][x] === EXIT) drawIcon(x, y, "‚õ©Ô∏è", "#0f0");
        if(grid[y][x] === COIN) drawIcon(x, y, "ü™ô", "#ff0");
        if(grid[y][x] === HIDE) drawIcon(x, y, "üåø", "#05a");
        if(grid[y][x] === TRAP) drawIcon(x, y, "ü™§", "#f0f");
        if(grid[y][x] === RICE) drawIcon(x, y, "üçô", "#fff");
        if(grid[y][x] === BOMB) drawIcon(x, y, "üí£", "#f50");
        if(grid[y][x] === CRACK) drawIcon(x, y, "üéá", "#0af");
        if(grid[y][x] === CHEST) drawIcon(x, y, "üì¶", "#da0");
        // Note: NOISE (Bell) is NOT rendered, making it invisible.
    }

    // Move Highlights
    if(playerTurn) {
        ctx.fillStyle = selectMode==='move' ? "rgba(0,170,255,0.15)" : "rgba(255,170,0,0.2)";
        const r = selectMode==='move' ? 2.5 : 1.5;
        for(let y=0; y<mapDim; y++) for(let x=0; x<mapDim; x++) {
            if(Math.hypot(x-player.x, y-player.y) < r && grid[y][x] === FLOOR) ctx.fillRect(x*TILE+2, y*TILE+2, TILE-4, TILE-4);
        }
    }

    // Enemies
    enemies.forEach(e => {
        if(!e.alive) return;
        ctx.fillStyle = "rgba(255,0,0,0.1)";
        ctx.beginPath(); ctx.moveTo(e.ax*TILE+25, e.ay*TILE+25);
        const a = Math.atan2(e.dir.y, e.dir.x);
        ctx.arc(e.ax*TILE+25, e.ay*TILE+25, e.range*TILE, a-0.5, a+0.5); ctx.fill();
        drawIcon(e.ax, e.ay, "üë∫", "#f33");
        
        // Status & Speech
        ctx.font = "bold 10px Arial"; ctx.textAlign = "center";
        ctx.fillStyle = e.status.includes("!") ? "#f00" : "#aaa";
        ctx.fillText(e.status, e.ax*TILE+25, e.ay*TILE-5);
        if(e.bubble) {
            ctx.fillStyle = "#fff"; ctx.font = "italic 9px Arial";
            ctx.fillText(`"${e.bubble}"`, e.ax*TILE+25, e.ay*TILE-15);
        }
    });

    drawIcon(player.ax, player.ay, player.hidden ? "üë§" : "ü•∑", "#0af");
    particles.forEach((p, i) => { p.update(); p.draw(ctx); if(p.life <= 0) particles.splice(i, 1); });
}

function drawIcon(x, y, ico, color) {
    ctx.fillStyle = color; ctx.font = "24px Arial"; ctx.textAlign = "center";
    ctx.fillText(ico, x*TILE+25, y*TILE+33);
}

function animMove(obj, tx, ty, cb) {
    const sx = obj.ax, sy = obj.ay;
    let p = 0;
    if(obj !== player) obj.dir = {x: Math.sign(tx-obj.x), y: Math.sign(ty-obj.y) || obj.dir.y};
    function step() {
        p += 0.2;
        obj.ax = sx + (tx-sx)*p;
        obj.ay = sy + (ty-sy)*p;
        if(p < 1) requestAnimationFrame(step);
        else { obj.x = tx; obj.y = ty; obj.ax = tx; obj.ay = ty; cb(); }
    }
    step();
}

function hasLineOfSight(e, px, py) {
    const dx = px-e.x, dy = py-e.y, d = Math.hypot(dx, dy);
    if(d > e.range) return false;
    const a = Math.abs(Math.atan2(dy, dx) - Math.atan2(e.dir.y, e.dir.x));
    return a < 0.6 || a > 5.6;
}

function spawnPart(x, y, c, count) {
    for(let i=0; i<count; i++) particles.push(new Particle(x*TILE+25, y*TILE+25, c, 6, 35));
}

class Particle {
    constructor(x, y, color, s, l) {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random()-0.5)*s; this.vy = (Math.random()-0.5)*s;
        this.life = l; this.max = l;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
    draw(ctx) { ctx.globalAlpha = this.life/this.max; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, 4, 4); ctx.globalAlpha = 1; }
}

function setMode(m) {
    selectMode = m;
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('btn' + m.charAt(0).toUpperCase() + m.slice(1)).classList.add('active');
}

function updateUI() {
    document.getElementById('c-trap').innerText = inv.trap;
    document.getElementById('c-rice').innerText = inv.rice;
    document.getElementById('c-bomb').innerText = inv.bomb;
    document.getElementById('c-crack').innerText = inv.crack;
}

function log(m) {
    const el = document.getElementById('msgLog');
    el.innerHTML = `<div class="log-msg">> ${m}</div>` + el.innerHTML;
    if(el.childNodes.length > 3) el.removeChild(el.lastChild);
}

function triggerDeath() { gameOver = true; shake=20; document.getElementById('gameOverScreen').classList.remove('hidden'); }

function win() {
    gameOver = true;
    const score = (gameStats.coins * 200) + (gameStats.kills * 300) - (gameStats.turns * 5);
    document.getElementById('stats').innerHTML = `Turns: ${gameStats.turns}<br>Kills: ${gameStats.kills}<br>Coins: ${gameStats.coins}<br><b>Score: ${score}</b>`;
    document.getElementById('resultScreen').classList.remove('hidden');
}

function playerWait() { if(playerTurn) { playerTurn = false; gameStats.turns++; endTurn(); } }
</script>
</body>
</html>
