<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Silent House: Tactical Mastery</title>
<style>
    body { margin: 0; background: #050505; color: #eee; font-family: 'Courier New', monospace; text-align: center; touch-action: none; overflow: hidden; }
    canvas { display: block; margin: 0 auto; background: #111; border: 2px solid #333; }
    #menu, #gameOverScreen, #resultScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 20; display: flex; flex-direction: column; justify-content: center; align-items: center; }
    .hidden { display: none !important; }
    .setting-group { margin: 5px; display: flex; align-items: center; justify-content: center; gap: 8px; font-size: 14px; }
    input { background: #222; color: #0af; border: 1px solid #444; padding: 4px; width: 45px; text-align: center; }
    button { padding: 10px 18px; margin: 4px; background: #1a1a1a; color: #eee; border: 1px solid #444; cursor: pointer; font-size: 12px; }
    button.active { background: #0af; color: #000; border-color: #fff; box-shadow: 0 0 10px #0af; }
    #ui-layer { position: fixed; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; }
    #info { margin-top: 10px; align-self: center; width: 90%; }
    #controls { margin-bottom: 15px; align-self: center; pointer-events: auto; background: rgba(0,0,0,0.8); padding: 8px; border: 1px solid #333; display: flex; flex-wrap: wrap; justify-content: center; border-radius: 8px; }
    .message { background: rgba(0,0,0,0.7); padding: 4px 10px; border-left: 3px solid #0af; margin-bottom: 2px; font-size: 12px; color: #0af; text-align: left; }
    .stat-line { width: 250px; display: flex; justify-content: space-between; margin: 5px; font-size: 16px; border-bottom: 1px solid #222; }
</style>
</head>
<body>

<div id="menu">
    <h1 style="color:#0af; letter-spacing: 5px;">SILENT HOUSE</h1>
    <div class="setting-group">Map: <input type="number" id="inpW" value="12">x<input type="number" id="inpH" value="12"> Guards: <input type="number" id="inpE" value="4"></div>
    <p style="color:#f80; margin: 5px;">LOADOUT</p>
    <div class="setting-group">Traps: <input type="number" id="inpTraps" value="2"> Rice: <input type="number" id="inpRice" value="2"></div>
    <div class="setting-group">Bombs: <input type="number" id="inpBombs" value="2"> Crackers: <input type="number" id="inpCracks" value="2"></div>
    <button onclick="startGame()">START MISSION</button>
</div>

<div id="resultScreen" class="hidden">
    <h2 style="color:#0af; letter-spacing: 3px;">MISSION COMPLETE</h2>
    <div class="stat-line"><span>Turns Speed:</span><span id="statTurns">0</span></div>
    <div class="stat-line"><span>Guards Eliminated:</span><span id="statKills">0</span></div>
    <div class="stat-line"><span>Coins Found:</span><span id="statCoins">0</span></div>
    <div id="rankDisplay" style="font-size:32px; margin: 20px; color: #fff; text-shadow: 0 0 10px #0af;">GRAND MASTER</div>
    <button onclick="generateLevel()">NEXT FLOOR</button>
</div>

<div id="gameOverScreen" class="hidden">
    <h1 style="color:#f00; letter-spacing: 4px;">ELIMINATED</h1>
    <button onclick="startGame()">RETRY</button>
</div>

<div id="ui-layer">
    <div id="info"></div>
    <div id="controls" class="hidden">
        <button id="btnMove" class="active" onclick="setMode('move')">MOVE</button>
        <button id="btnTrap" onclick="setMode('trap')">TRAP (<span id="countTrap">0</span>)</button>
        <button id="btnRice" onclick="setMode('rice')">RICE (<span id="countRice">0</span>)</button>
        <button id="btnBomb" onclick="setMode('bomb')">BOMB (<span id="countBomb">0</span>)</button>
        <button id="btnCrack" onclick="setMode('crack')">CRACKER (<span id="countCrack">0</span>)</button>
        <button onclick="playerWait()">WAIT</button>
    </div>
</div>

<canvas id="game" class="hidden"></canvas>

<script>
const TILE = 48;
const FLOOR=0, WALL=1, NOISE=2, EXIT=3, HIDE=4, COIN=5, TRAP_SET=6, RICE_SET=7, BOMB_SET=8, CRACK_SET=9;
let grid, player, enemies, gameOver = false, playerTurn = true;
let mapW, mapH, inventory = {}, selectMode = 'move', particles = [];
let stats = { turns: 0, kills: 0, coins: 0 };
let activeTools = []; // Store bombs and crackers
let shake = 0;

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

class Particle {
    constructor(x, y, color, speed, life) {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random()-0.5) * speed;
        this.vy = (Math.random()-0.5) * speed;
        this.life = life; this.maxLife = life;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
    draw(ctx) {
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 3, 3);
        ctx.globalAlpha = 1;
    }
}

function triggerShake(amt) { shake = amt; }

function spawnExplosion(x, y, color="#f50", count=30) {
    triggerShake(15);
    for(let i=0; i<count; i++) particles.push(new Particle(x*TILE+24, y*TILE+24, color, 6, 35));
}

function setMode(m) {
    selectMode = m;
    document.querySelectorAll('#controls button').forEach(b => b.classList.remove('active'));
    document.getElementById('btn' + m.charAt(0).toUpperCase() + m.slice(1)).classList.add('active');
    draw();
}

function startGame() {
    mapW = parseInt(document.getElementById("inpW").value);
    mapH = parseInt(document.getElementById("inpH").value);
    inventory = {
        traps: parseInt(document.getElementById("inpTraps").value),
        rice: parseInt(document.getElementById("inpRice").value),
        bombs: parseInt(document.getElementById("inpBombs").value),
        crackers: parseInt(document.getElementById("inpCracks").value)
    };
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    document.getElementById("menu").classList.add("hidden");
    document.getElementById("gameOverScreen").classList.add("hidden");
    canvas.classList.remove("hidden");
    document.getElementById("controls").classList.remove("hidden");
    generateLevel();
}

function generateLevel() {
    document.getElementById("resultScreen").classList.add("hidden");
    gameOver = false; playerTurn = true; activeTools = []; particles = [];
    stats = { turns: 0, kills: 0, coins: 0 };
    updateUI();

    grid = Array.from({length: mapH}, (_, y) => Array.from({length: mapW}, (_, x) => 
        (x===0 || y===0 || x===mapW-1 || y===mapH-1) ? WALL : Math.random() < 0.2 ? WALL : FLOOR
    ));

    player = { x: 1, y: 1, animX: 1, animY: 1, hidden: false };
    for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) if(isValid(1+i, 1+j)) grid[1+j][1+i] = FLOOR;

    let ex, ey; do { ex = Math.floor(Math.random()*(mapW-2))+1; ey = Math.floor(Math.random()*(mapH-2))+1; } while(grid[ey][ex] !== FLOOR || Math.hypot(ex-1, ey-1) < 6);
    grid[ey][ex] = EXIT;

    for(let i=0; i<3; i++) placeRandom(NOISE);
    for(let i=0; i<3; i++) placeRandom(HIDE);
    for(let i=0; i<5; i++) placeRandom(COIN);

    enemies = [];
    let countE = parseInt(document.getElementById("inpE").value);
    for(let i=0; i<countE; i++) {
        let enX, enY; do { enX = Math.floor(Math.random()*(mapW-2))+1; enY = Math.floor(Math.random()*(mapH-2))+1; }
        while(grid[enY][enX] !== FLOOR || Math.hypot(enX-1, enY-1) < 5);
        enemies.push({ x: enX, y: enY, animX: enX, animY: enY, dir: {x:1, y:0}, target: null, visionRange: 4, mark: null, alive: true });
    }
    draw();
}

function updateUI() {
    document.getElementById('countTrap').innerText = inventory.traps;
    document.getElementById('countRice').innerText = inventory.rice;
    document.getElementById('countBomb').innerText = inventory.bombs;
    document.getElementById('countCrack').innerText = inventory.crackers;
}

function placeRandom(type) {
    let x, y; do { x = Math.floor(Math.random()*(mapW-2))+1; y = Math.floor(Math.random()*(mapH-2))+1; } while(grid[y][x] !== FLOOR);
    grid[y][x] = type;
}

function isValid(x, y) { return x >= 0 && y >= 0 && x < mapW && y < mapH && grid[y][x] !== WALL; }

canvas.addEventListener("pointerdown", e => {
    if(!playerTurn || gameOver) return;
    const scale = Math.min(canvas.width/(mapW*TILE), canvas.height/(mapH*TILE));
    const ox = (canvas.width - mapW*TILE*scale)/2, oy = (canvas.height - mapH*TILE*scale)/2;
    const tx = Math.floor(((e.clientX - ox) / scale) / TILE), ty = Math.floor(((e.clientY - oy) / scale) / TILE);

    if(!isValid(tx, ty)) return;
    const dist = Math.hypot(tx - player.x, ty - player.y);

    if(selectMode === 'move') {
        if(dist > 0 && dist <= 2.2) {
            playerTurn = false; stats.turns++;
            animateMove(player, tx, ty, () => { checkTile(); enemyTurn(); });
        }
    } else {
        if(dist > 1.5 || grid[ty][tx] !== FLOOR) return;
        if(selectMode === 'trap' && inventory.traps > 0) { grid[ty][tx] = TRAP_SET; inventory.traps--; showMessage("TRAP SET."); }
        else if(selectMode === 'rice' && inventory.rice > 0) { grid[ty][tx] = RICE_SET; inventory.rice--; showMessage("RICE DEPLOYED."); }
        else if(selectMode === 'bomb' && inventory.bombs > 0) { 
            grid[ty][tx] = BOMB_SET; inventory.bombs--; 
            activeTools.push({x:tx, y:ty, type:'bomb', timer:2}); 
            showMessage("BOMB ARMED: 2 TURNS."); 
        }
        else if(selectMode === 'crack' && inventory.crackers > 0) { 
            grid[ty][tx] = CRACK_SET; inventory.crackers--; 
            activeTools.push({x:tx, y:ty, type:'cracker', timer:2, uses:2}); 
            showMessage("CRACKER SET: WILL POP TWICE."); 
        }
        updateUI(); playerTurn = false; enemyTurn();
    }
});

async function enemyTurn() {
    const activeEnemies = enemies.filter(e => e.alive);
    for(let e of activeEnemies) {
        if(!e.alive || gameOver) continue;
        await new Promise(r => setTimeout(r, 150));
        
        if(grid[e.y][e.x] === TRAP_SET) { e.alive = false; grid[e.y][e.x] = FLOOR; spawnExplosion(e.x, e.y, "#888"); stats.kills++; continue; }
        if(grid[e.y][e.x] === RICE_SET) { e.alive = false; grid[e.y][e.x] = FLOOR; spawnExplosion(e.x, e.y, "#fff", 10); stats.kills++; continue; }

        let nx = e.x, ny = e.y;
        if(e.target) {
            let path = findPath(e.x, e.y, e.target.x, e.target.y);
            if(path && path.length > 1) { nx = path[1].x; ny = path[1].y; }
            if(e.x === e.target.x && e.y === e.target.y) e.target = null;
        } else {
            const d = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}][Math.floor(Math.random()*4)];
            if(isValid(e.x+d.x, e.y+d.y)) { nx += d.x; ny += d.y; }
        }
        if(isValid(nx, ny) && !activeEnemies.some(o => o!==e && o.alive && o.x === nx && o.y === ny)) await new Promise(r => animateMove(e, nx, ny, r));
        if(!player.hidden && isInVision(e, player.x, player.y)) { triggerShake(20); triggerGameOver(); return; }
    }
    
    // Process Timed Tools at start of next player turn
    for(let i = activeTools.length-1; i >= 0; i--) {
        let t = activeTools[i];
        t.timer--;
        if(t.timer <= 0) {
            if(t.type === 'bomb') {
                spawnExplosion(t.x, t.y, "#f50", 40);
                grid[t.y][t.x] = FLOOR;
                enemies.forEach(en => { if(en.alive && Math.hypot(en.x-t.x, en.y-t.y) < 10) { en.target = {x:t.x, y:t.y}; en.mark = "!!"; }});
                activeTools.splice(i, 1);
            } else if(t.type === 'cracker') {
                spawnExplosion(t.x, t.y, "#fff", 15);
                enemies.forEach(en => { if(en.alive && Math.hypot(en.x-t.x, en.y-t.y) < 7) { en.target = {x:t.x, y:t.y}; en.mark = "?"; }});
                t.uses--;
                if(t.uses > 0) t.timer = 2; // Reset for second pop
                else { grid[t.y][t.x] = FLOOR; activeTools.splice(i, 1); }
            }
        }
    }

    playerTurn = true; setMode('move');
}

function findPath(sx, sy, tx, ty) {
    let q = [[{x:sx, y:sy}]], v = new Set([sx+','+sy]);
    while(q.length > 0) {
        let p = q.shift(), c = p[p.length-1];
        if(c.x === tx && c.y === ty) return p;
        for(let d of [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}]) {
            let n = {x:c.x+d.x, y:c.y+d.y};
            if(isValid(n.x, n.y) && !v.has(n.x+','+n.y)) { v.add(n.x+','+n.y); q.push([...p, n]); }
        }
    }
    return null;
}

function isInVision(e, px, py) {
    const dx = px - e.x, dy = py - e.y, dist = Math.hypot(dx, dy);
    if(dist > e.visionRange) return false;
    const ang = Math.abs(Math.atan2(dy, dx) - Math.atan2(e.dir.y, e.dir.x));
    if(ang > 0.8 && ang < 5.5) return false;
    let steps = dist * 2;
    for(let i=1; i<=steps; i++) {
        let tx = Math.floor(e.x + dx*(i/steps)), ty = Math.floor(e.y + dy*(i/steps));
        if(grid[ty] && grid[ty][tx] === WALL) return false;
    }
    return true;
}

function animateMove(ent, tx, ty, cb) {
    const sX = ent.animX, sY = ent.animY;
    let progress = 0;
    if(ent !== player) ent.dir = {x: Math.sign(tx - ent.x), y: Math.sign(ty - ent.y)};
    function step() {
        progress += 0.2;
        ent.animX = sX + (tx - sX) * progress;
        ent.animY = sY + (ty - sY) * progress;
        draw();
        if(progress < 1) requestAnimationFrame(step);
        else { ent.x = tx; ent.y = ty; ent.animX = tx; ent.animY = ty; cb(); }
    }
    step();
}

function draw() {
    const scale = Math.min(canvas.width/(mapW*TILE), canvas.height/(mapH*TILE));
    const ox = (canvas.width - mapW*TILE*scale)/2 + (Math.random()-0.5)*shake;
    const oy = (canvas.height - mapH*TILE*scale)/2 + (Math.random()-0.5)*shake;
    if(shake > 0) shake *= 0.85;

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.translate(ox, oy); ctx.scale(scale, scale);

    for(let y=0; y<mapH; y++) for(let x=0; x<mapW; x++) {
        ctx.fillStyle = grid[y][x] === WALL ? "#222" : "#0d0d0d";
        ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        if(grid[y][x] === EXIT) { ctx.fillStyle="#080"; ctx.fillRect(x*TILE+8, y*TILE+8, TILE-16, TILE-16); }
        if(grid[y][x] === COIN) { ctx.fillStyle="#ff0"; ctx.beginPath(); ctx.arc(x*TILE+24, y*TILE+24, 6, 0, 7); ctx.fill(); }
        if(grid[y][x] === TRAP_SET) { ctx.strokeStyle="#f0f"; ctx.strokeRect(x*TILE+15, y*TILE+15, 18, 18); }
        if(grid[y][x] === RICE_SET) { ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(x*TILE+24, y*TILE+24, 5, 0, 7); ctx.fill(); }
        if(grid[y][x] === BOMB_SET) { ctx.fillStyle="#f30"; ctx.fillRect(x*TILE+16, y*TILE+16, 16, 16); }
        if(grid[y][x] === CRACK_SET) { ctx.fillStyle="#0af"; ctx.beginPath(); ctx.arc(x*TILE+24, y*TILE+24, 6, 0, 7); ctx.fill(); }
        if(grid[y][x] === HIDE) { ctx.fillStyle="rgba(0,10,50,0.5)"; ctx.fillRect(x*TILE+5, y*TILE+5, TILE-10, TILE-10); }
    }

    if(playerTurn && !gameOver) {
        ctx.fillStyle = selectMode === 'move' ? "rgba(0,180,255,0.1)" : "rgba(255,100,0,0.15)";
        let range = selectMode === 'move' ? 2.2 : 1.5;
        for(let dy=-3; dy<=3; dy++) for(let dx=-3; dx<=3; dx++) {
            let tx = player.x+dx, ty = player.y+dy;
            if(isValid(tx, ty) && Math.hypot(dx,dy) <= range && grid[ty][tx] !== WALL) ctx.fillRect(tx*TILE, ty*TILE, TILE, TILE);
        }
    }

    particles.forEach((p, i) => { p.update(); p.draw(ctx); if(p.life <= 0) particles.splice(i, 1); });

    enemies.forEach(e => {
        if(!e.alive) return;
        ctx.fillStyle = "rgba(255,0,0,0.1)";
        ctx.beginPath(); ctx.moveTo(e.animX*TILE+24, e.animY*TILE+24);
        const a = Math.atan2(e.dir.y, e.dir.x);
        ctx.arc(e.animX*TILE+24, e.animY*TILE+24, e.visionRange*TILE, a-0.6, a+0.6); ctx.fill();
        ctx.fillStyle = "#f33"; ctx.fillRect(e.animX*TILE+12, e.animY*TILE+12, 24, 24);
        if(e.mark) { ctx.fillStyle="#fff"; ctx.font="bold 12px Arial"; ctx.fillText(e.mark, e.animX*TILE+10, e.animY*TILE+10); }
    });

    ctx.fillStyle = player.hidden ? "rgba(0,150,255,0.4)" : "#0af";
    ctx.fillRect(player.animX*TILE+12, player.animY*TILE+12, 24, 24);
    if(particles.length > 0 || shake > 0.1) requestAnimationFrame(draw);
}

function checkTile() {
    const t = grid[player.y][player.x];
    player.hidden = (t === HIDE);
    if(t === COIN) { stats.coins++; grid[player.y][player.x] = FLOOR; showMessage("COIN COLLECTED."); }
    if(t === EXIT) { 
        gameOver = true; 
        document.getElementById("resultScreen").classList.remove("hidden");
        document.getElementById("statTurns").innerText = stats.turns + " (" + Math.max(0, 500 - stats.turns*10) + " pts)";
        document.getElementById("statKills").innerText = stats.kills + " (" + (stats.kills*100) + " pts)";
        document.getElementById("statCoins").innerText = stats.coins + " (" + (stats.coins*150) + " pts)";
        
        let score = (stats.coins * 150) + (stats.kills * 100) + Math.max(0, 500 - stats.turns*10);
        let rank = score > 1200 ? "GRAND MASTER" : score > 800 ? "MASTER NINJA" : "EXPERT";
        document.getElementById("rankDisplay").innerText = rank;
    }
}

function triggerGameOver() { gameOver = true; draw(); setTimeout(() => document.getElementById("gameOverScreen").classList.remove("hidden"), 300); }
function playerWait() { if(playerTurn) { playerTurn = false; stats.turns++; enemyTurn(); } }
function showMessage(m) {
    const d = document.createElement("div"); d.className="message"; d.textContent=m;
    const box = document.getElementById("info"); box.prepend(d);
    if(box.childNodes.length > 3) box.removeChild(box.lastChild);
}
</script>
</body>
</html>
