<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Shadow Protocol: Tactical Stealth</title>
<style>
    :root { --accent: #d4af37; --bg: #050505; --red: #ff4444; --blue: #00d2ff; --panel: rgba(15, 15, 15, 0.9); }
    body { margin: 0; background: var(--bg); color: #eee; font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none; }
    canvas { display: block; margin: 0 auto; background: #000; }
    
    /* Log System */
    #missionLog { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 400px; height: 60px; background: rgba(0,0,0,0.7); border-left: 3px solid var(--accent); padding: 5px 10px; font-size: 11px; overflow-y: hidden; z-index: 15; pointer-events: none; color: #aaa; display: flex; flex-direction: column-reverse; }
    .log-entry { margin-bottom: 2px; animation: fadeIn 0.3s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translateX(-5px); } to { opacity: 1; transform: translateX(0); } }

    .overlay-screen { position: fixed; inset: 0; background: rgba(0,0,0,0.98); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 20; }
    .hidden { display: none !important; }

    /* Tactical Menu */
    .menu-card { background: var(--panel); border: 1px solid var(--accent); padding: 30px; border-radius: 8px; width: 320px; box-shadow: 0 0 50px #000; }
    .config-row { display: flex; justify-content: space-between; align-items: center; margin: 12px 0; border-bottom: 1px solid #333; padding-bottom: 8px; }
    .config-row input { background: #000; border: 1px solid #444; color: var(--accent); width: 50px; text-align: center; }

    /* Modern Buttons */
    #toolbar { position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; z-index: 10; padding: 10px; }
    .tool-btn { 
        width: 65px; height: 65px; background: rgba(30,30,30,0.8); border: 1px solid #444; 
        color: #fff; display: flex; flex-direction: column; align-items: center; justify-content: center; 
        font-size: 10px; cursor: pointer; transition: 0.3s; border-radius: 12px; backdrop-filter: blur(10px);
    }
    .tool-btn.active { border-color: var(--blue); background: rgba(0, 210, 255, 0.2); box-shadow: 0 0 15px var(--blue); }
    .tool-btn span { font-size: 18px; margin-bottom: 4px; }
    
    .btn-main { width: 100%; padding: 15px; background: var(--accent); color: #000; border: none; cursor: pointer; font-weight: bold; text-transform: uppercase; letter-spacing: 2px; border-radius: 4px; }
</style>
</head>
<body>

<div id="missionLog"></div>

<div id="menu" class="overlay-screen">
    <div class="menu-card">
        <h2 style="color:var(--accent); text-align: center; letter-spacing: 5px; margin-top:0;">SHADOW PROTOCOL</h2>
        <div class="config-row"><label>Map Size (Max 15)</label><input type="number" id="mapSize" value="12" max="15"></div>
        <div class="config-row"><label>Guards (Max 15)</label><input type="number" id="guardCount" value="4" max="15"></div>
        <div class="config-row"><label>Steel Traps</label><input type="number" id="setTrap" value="3"></div>
        <div class="config-row"><label>Rice Lures</label><input type="number" id="setRice" value="2"></div>
        <div class="config-row"><label>Smoke Bombs</label><input type="number" id="setBomb" value="1"></div>
        <button class="btn-main" onclick="initGame()">Deploy</button>
    </div>
</div>

<div id="gameOverScreen" class="overlay-screen hidden">
    <h1 style="color:var(--red); letter-spacing: 10px;">MISSION FAILED</h1>
    <button class="btn-main" style="width:200px" onclick="location.reload()">Retry</button>
</div>

<canvas id="game"></canvas>

<div id="toolbar" class="hidden">
    <div class="tool-btn active" id="btnMove" onclick="setMode('move')"><span>üë£</span>Move</div>
    <div class="tool-btn" id="btnTrap" onclick="setMode('trap')"><span>‚öôÔ∏è</span>Trap (<span id="c-trap">0</span>)</div>
    <div class="tool-btn" id="btnRice" onclick="setMode('rice')"><span>üçö</span>Rice (<span id="c-rice">0</span>)</div>
    <div class="tool-btn" id="btnBomb" onclick="setMode('bomb')"><span>üí£</span>Bomb (<span id="c-bomb">0</span>)</div>
    <div class="tool-btn" onclick="playerWait()"><span>‚åõ</span>Wait</div>
</div>

<script>
const TILE = 60;
const FLOOR=0, WALL=1, HIDE=2, EXIT=3, COIN=5, TRAP=6, RICE=7, BOMB=8;

let grid, player, enemies, activeBombs = [], turnCount = 1;
let selectMode = 'move', gameOver = false, playerTurn = true, shake = 0, mapDim = 12;
let inv = { trap: 0, rice: 0, bomb: 0 };

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const sprites = {};

['player', 'guard', 'wall', 'floor', 'exit', 'trap', 'rice', 'bomb', 'coin', 'hide'].forEach(n => {
    const img = new Image(); img.src = `sprites/${n}.png`;
    img.onload = () => sprites[n] = img;
});

function log(msg, color="#eee") {
    const div = document.createElement('div');
    div.className = 'log-entry';
    div.style.color = color;
    div.innerText = `> ${msg}`;
    const container = document.getElementById('missionLog');
    container.prepend(div);
}

function initGame() {
    mapDim = Math.min(15, parseInt(document.getElementById('mapSize').value));
    inv.trap = parseInt(document.getElementById('setTrap').value);
    inv.rice = parseInt(document.getElementById('setRice').value);
    inv.bomb = parseInt(document.getElementById('setBomb').value);
    
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('toolbar').classList.remove('hidden');
    generateLevel();
    updateUI();
    log("Mission started. Infiltrate the facility.", "var(--accent)");
    requestAnimationFrame(gameLoop);
}

function generateLevel() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    grid = Array.from({length: mapDim}, (_, y) => Array.from({length: mapDim}, (_, x) => 
        (x==0 || y==0 || x==mapDim-1 || y==mapDim-1) ? WALL : Math.random() < 0.18 ? WALL : Math.random() < 0.08 ? HIDE : FLOOR
    ));
    player = { x: 1, y: 1, ax: 1, ay: 1, isHidden: false };
    grid[mapDim-2][mapDim-2] = EXIT;
    
    const gc = Math.min(15, parseInt(document.getElementById('guardCount').value));
    enemies = [];
    for(let i=0; i<gc; i++) {
        let ex, ey; do { ex = Math.floor(Math.random()*(mapDim-2))+1; ey = Math.floor(Math.random()*(mapDim-2))+1; }
        while(grid[ey][ex] !== FLOOR || Math.hypot(ex-player.x, ey-player.y) < 4);
        enemies.push({ x: ex, y: ey, ax: ex, ay: ey, dir: {x:1, y:0}, alive: true, range: 4 });
    }
}

function drawSprite(n, x, y) {
    const px = x*TILE, py = y*TILE;
    if(sprites[n]) {
        ctx.drawImage(sprites[n], px, py, TILE, TILE);
    } else {
        ctx.beginPath();
        if(n === 'player') { 
            ctx.fillStyle = player.isHidden ? "rgba(0,210,255,0.4)" : "#00d2ff";
            ctx.arc(px+30, py+30, 16, 0, 7); ctx.fill(); 
        } else if(n === 'guard') { 
            ctx.fillStyle="#ff4444"; ctx.fillRect(px+15, py+15, 30, 30); 
        } else if(n === 'wall') { 
            ctx.fillStyle="#1a1a1a"; ctx.fillRect(px,py,TILE,TILE); 
            ctx.strokeStyle="#333"; ctx.strokeRect(px+4,py+4,TILE-8,TILE-8);
        } else if(n === 'floor') { 
            ctx.fillStyle="#080808"; ctx.fillRect(px,py,TILE,TILE); 
        } else if(n === 'hide') { 
            ctx.strokeStyle=varColor('--accent'); ctx.lineWidth=2;
            ctx.strokeRect(px+12, py+12, TILE-24, TILE-24);
            ctx.lineWidth=1;
        } else if(n === 'exit') { 
            ctx.strokeStyle="#0f0"; ctx.lineWidth=3;
            ctx.strokeRect(px+5, py+5, TILE-10, TILE-10);
            ctx.shadowBlur = 10; ctx.shadowColor = "#0f0";
            ctx.strokeRect(px+15, py+15, TILE-30, TILE-30);
            ctx.shadowBlur = 0;
        }
    }
}

function gameLoop() {
    if(gameOver) return;
    const scale = Math.min(canvas.width/(mapDim*TILE), canvas.height/(mapDim*TILE));
    const ox = (canvas.width - mapDim*TILE*scale)/2 + (Math.random()-0.5)*shake;
    const oy = (canvas.height - mapDim*TILE*scale)/2 + (Math.random()-0.5)*shake;
    shake *= 0.9;

    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = "#000"; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.translate(ox, oy); ctx.scale(scale, scale);

    for(let y=0; y<mapDim; y++) for(let x=0; x<mapDim; x++) {
        drawSprite('floor', x, y);
        const cell = grid[y][x];
        if(cell === WALL) drawSprite('wall', x, y);
        else if(cell === HIDE) drawSprite('hide', x, y);
        else if(cell === EXIT) drawSprite('exit', x, y);
        else if(cell === TRAP) drawSprite('trap', x, y);
        else if(cell === RICE) drawSprite('rice', x, y);
        else if(cell === BOMB) drawSprite('bomb', x, y);
    }

    // Highlights
    if(playerTurn) {
        ctx.strokeStyle = selectMode === 'move' ? "var(--blue)" : "var(--accent)";
        ctx.shadowBlur = 8; ctx.shadowColor = ctx.strokeStyle;
        ctx.lineWidth = 2;
        for(let dy=-2; dy<=2; dy++) for(let dx=-2; dx<=2; dx++) {
            let tx = player.x + dx, ty = player.y + dy;
            if(tx > 0 && tx < mapDim-1 && ty > 0 && ty < mapDim-1 && grid[ty][tx] !== WALL) {
                if(grid[player.y + Math.sign(dy)][player.x + Math.sign(dx)] !== WALL)
                    ctx.strokeRect(tx*TILE+6, ty*TILE+6, TILE-12, TILE-12);
            }
        }
        ctx.shadowBlur = 0;
    }

    enemies.forEach(e => {
        if(!e.alive) return;
        drawSprite('guard', e.ax, e.ay);
        // Vision
        ctx.fillStyle = "rgba(255, 0, 0, 0.15)";
        ctx.beginPath(); ctx.moveTo(e.ax*TILE+30, e.ay*TILE+30);
        const baseA = Math.atan2(e.dir.y, e.dir.x);
        for(let a = baseA-0.7; a <= baseA+0.7; a += 0.05) {
            let d = 0; while(d < e.range) {
                d += 0.2; if(grid[Math.floor(e.y + Math.sin(a)*d)]?.[Math.floor(e.x + Math.cos(a)*d)] === WALL) break;
            }
            ctx.lineTo(e.ax*TILE+30 + Math.cos(a)*d*TILE, e.ay*TILE+30 + Math.sin(a)*d*TILE);
        }
        ctx.fill();
    });

    drawSprite('player', player.ax, player.ay);
    requestAnimationFrame(gameLoop);
}

canvas.addEventListener('pointerdown', e => {
    if(!playerTurn || gameOver) return;
    const scale = Math.min(canvas.width/(mapDim*TILE), canvas.height/(mapDim*TILE));
    const ox = (canvas.width - mapDim*TILE*scale)/2, oy = (canvas.height - mapDim*TILE*scale)/2;
    const tx = Math.floor(((e.clientX - ox)/scale)/TILE), ty = Math.floor(((e.clientY - oy)/scale)/TILE);
    
    if (grid[ty]?.[tx] === undefined || grid[ty][tx] === WALL) return;

    const dx = tx - player.x, dy = ty - player.y;
    const dist = Math.max(Math.abs(dx), Math.abs(dy));

    if(selectMode === 'move' && dist <= 2) {
        if(grid[player.y + Math.sign(dy)][player.x + Math.sign(dx)] === WALL) return;
        playerTurn = false;
        animMove(player, tx, ty, 0.1, () => {
            player.isHidden = (grid[ty][tx] === HIDE);
            if(player.isHidden) log("Player hidden in shadows", "var(--blue)");
            if(grid[ty][tx] === EXIT) { log("Extraction successful!", "#0f0"); setTimeout(()=>location.reload(), 2000); }
            endTurn();
        });
    } else if(selectMode !== 'move' && dist <= 2 && grid[ty][tx] === FLOOR) {
        deployTool(tx, ty);
    }
});

function deployTool(tx, ty) {
    if(selectMode === 'trap' && inv.trap > 0) { grid[ty][tx] = TRAP; inv.trap--; log("Trap deployed"); }
    else if(selectMode === 'rice' && inv.rice > 0) { grid[ty][tx] = RICE; inv.rice--; log("Rice lure placed"); }
    else if(selectMode === 'bomb' && inv.bomb > 0) { grid[ty][tx] = BOMB; inv.bomb--; activeBombs.push({x:tx, y:ty, t:3}); log("Bomb armed: 3 turns", "var(--red)"); }
    else return;
    updateUI(); playerTurn = false; endTurn();
}

async function endTurn() {
    log(`--- Turn ${turnCount} ---`, "#555");
    activeBombs.forEach((b, i) => {
        b.t--; 
        if(b.t <= 0) {
            grid[b.y][b.x] = FLOOR; shake = 30; log("SMOKE BOMB DETONATED!", "var(--red)");
            enemies.forEach(e => { if(Math.abs(e.x-b.x) <= 1 && Math.abs(e.y-b.y) <= 1) e.alive = false; });
            activeBombs.splice(i, 1);
        }
    });

    for(let i=0; i<enemies.length; i++) {
        const e = enemies[i];
        if(!e.alive) continue;
        await new Promise(r => setTimeout(r, 400));
        
        if(grid[e.y][e.x] === TRAP) { e.alive = false; grid[e.y][e.x] = FLOOR; log(`Guard ${i+1} neutralized by trap`, "var(--red)"); continue; }
        
        let nx = e.x, ny = e.y;
        const d = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}][Math.floor(Math.random()*4)];
        if(grid[e.y+d.y]?.[e.x+d.x] === FLOOR) { nx+=d.x; ny+=d.y; }
        
        await new Promise(r => animMove(e, nx, ny, 0.08, r));
        
        if(!player.isHidden && hasLineOfSight(e, player.x, player.y)) {
            log("SPOTTED! Security alerted.", "var(--red)");
            gameOver = true; document.getElementById('gameOverScreen').classList.remove('hidden'); return;
        }
    }
    turnCount++;
    playerTurn = true;
}

function hasLineOfSight(e, px, py) {
    const dx = px-e.x, dy = py-e.y, dist = Math.hypot(dx, dy);
    if(dist > e.range) return false;
    const ang = Math.abs(Math.atan2(dy, dx) - Math.atan2(e.dir.y, e.dir.x));
    if(ang > 0.8 && ang < 5.5) return false;
    for(let d=0.5; d<dist; d+=0.5) if(grid[Math.floor(e.y + (dy/dist)*d)]?.[Math.floor(e.x + (dx/dist)*d)] === WALL) return false;
    return true;
}

function animMove(obj, tx, ty, speed, cb) {
    const sx = obj.ax, sy = obj.ay; let p = 0;
    if(obj !== player) obj.dir = {x: Math.sign(tx-obj.x), y: Math.sign(ty-obj.y) || obj.dir.y};
    function step() {
        p += speed; obj.ax = sx + (tx-sx)*p; obj.ay = sy + (ty-sy)*p;
        if(p < 1) requestAnimationFrame(step); else { obj.x = tx; obj.y = ty; obj.ax = tx; obj.ay = ty; cb(); }
    }
    step();
}

function updateUI() { 
    document.getElementById('c-trap').innerText = inv.trap; 
    document.getElementById('c-rice').innerText = inv.rice; 
    document.getElementById('c-bomb').innerText = inv.bomb; 
}
function setMode(m) { 
    selectMode = m; 
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active')); 
    document.getElementById('btn' + m.charAt(0).toUpperCase() + m.slice(1)).classList.add('active'); 
}
function playerWait() { if(playerTurn) { playerTurn = false; log("Waiting..."); endTurn(); } }
function varColor(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
</script>
</body>
</html>
