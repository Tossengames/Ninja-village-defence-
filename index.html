<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Silent House: Shadow Protocol</title>
<style>
    :root { --accent: #0af; --bg: #050508; }
    body { margin: 0; background: var(--bg); color: #eee; font-family: 'Segoe UI', Tahoma, sans-serif; overflow: hidden; touch-action: none; }
    canvas { display: block; margin: 0 auto; filter: contrast(1.2) brightness(1.1); }
    
    /* UI Styling */
    #ui-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
    .overlay-screen { position: absolute; inset: 0; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; backdrop-filter: blur(5px); }
    .hidden { display: none !important; }

    #hud { position: absolute; top: 10px; width: 100%; display: flex; flex-direction: column; align-items: center; }
    .log { width: 300px; font-size: 12px; color: var(--accent); text-shadow: 0 0 5px var(--accent); }
    
    #toolbar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; pointer-events: auto; background: rgba(0,0,0,0.8); padding: 10px; border: 1px solid #333; border-radius: 12px; }
    .tool-btn { width: 50px; height: 60px; background: #111; border: 1px solid #444; color: #888; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 10px; border-radius: 6px; }
    .tool-btn.active { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 10px var(--accent); }
    .tool-btn b { font-size: 16px; margin-bottom: 4px; }

    h1 { letter-spacing: 10px; color: var(--accent); text-shadow: 0 0 20px var(--accent); }
    .btn-main { padding: 15px 40px; background: transparent; color: var(--accent); border: 2px solid var(--accent); cursor: pointer; font-weight: bold; transition: 0.3s; }
    .btn-main:hover { background: var(--accent); color: #000; }
</style>
</head>
<body>

<div id="ui-overlay">
    <div id="menu" class="overlay-screen">
        <h1>SHADOW PROTOCOL</h1>
        <p style="color: #666; margin-bottom: 30px;">STRATEGY ‚Ä¢ STEALTH ‚Ä¢ RISK</p>
        <button class="btn-main" onclick="startGame()">INFILTRATE</button>
    </div>

    <div id="resultScreen" class="overlay-screen hidden">
        <h2 id="winTitle" style="color:var(--accent)">MISSION SUCCESS</h2>
        <div id="stats" style="margin: 20px 0; text-align: left; width: 250px;"></div>
        <button class="btn-main" onclick="generateLevel()">DESCEND DEEPER</button>
    </div>

    <div id="hud">
        <div id="msgLog"></div>
    </div>

    <div id="toolbar" class="hidden">
        <div class="tool-btn active" id="btnMove" onclick="setMode('move')"><b>üë§</b>Move</div>
        <div class="tool-btn" id="btnTrap" onclick="setMode('trap')"><b>ü™§</b><span id="c-trap">0</span></div>
        <div class="tool-btn" id="btnRice" onclick="setMode('rice')"><b>üçô</b><span id="c-rice">0</span></div>
        <div class="tool-btn" id="btnBomb" onclick="setMode('bomb')"><b>üí£</b><span id="c-bomb">0</span></div>
        <div class="tool-btn" id="btnCrack" onclick="setMode('crack')"><b>üéá</b><span id="c-crack">0</span></div>
        <div class="tool-btn" onclick="playerWait()"><b>‚è≥</b>Wait</div>
    </div>
</div>

<canvas id="game"></canvas>

<script>
/** GAME CONSTANTS **/
const TILE = 50;
const FLOOR=0, WALL=1, NOISE=2, EXIT=3, HIDE=4, COIN=5, TRAP=6, RICE=7, BOMB=8, CRACK=9, CHEST=10;

let grid, player, enemies, particles = [], activeTools = [];
let selectMode = 'move', gameOver = false, playerTurn = true;
let stats = { turns: 0, kills: 0, coins: 0, floors: 0 };
let inv = { trap: 2, rice: 2, bomb: 1, crack: 2 };
let shake = 0;

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

/** ENGINE **/
function startGame() {
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('toolbar').classList.remove('hidden');
    stats.floors = 1;
    generateLevel();
}

function generateLevel() {
    document.getElementById('resultScreen').classList.add('hidden');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    const w = 12, h = 12;
    grid = Array.from({length: h}, (_, y) => Array.from({length: w}, (_, x) => 
        (x==0 || y==0 || x==w-1 || y==h-1) ? WALL : Math.random() < 0.18 ? WALL : FLOOR
    ));

    // Clear start and end
    player = { x: 1, y: 1, ax: 1, ay: 1, hidden: false };
    grid[1][1] = FLOOR;
    grid[h-2][w-2] = EXIT;

    // Add Gamble Chest & Junk
    placeRandom(CHEST, 1);
    placeRandom(COIN, 4);
    placeRandom(HIDE, 3);
    placeRandom(NOISE, 2);

    enemies = [];
    for(let i=0; i<3 + stats.floors; i++) {
        let ex, ey; do { ex = Math.floor(Math.random()*(w-2))+1; ey = Math.floor(Math.random()*(h-2))+1; }
        while(grid[ey][ex] !== FLOOR || Math.hypot(ex-1, ey-1) < 5);
        enemies.push({ x: ex, y: ey, ax: ex, ay: ey, dir: {x:1, y:0}, target: null, alive: true, range: 4 });
    }

    activeTools = [];
    playerTurn = true;
    gameOver = false;
    updateUI();
    loop();
}

function placeRandom(type, count) {
    for(let i=0; i<count; i++) {
        let x, y; do { x = Math.floor(Math.random()*10)+1; y = Math.floor(Math.random()*10)+1; } while(grid[y][x] !== FLOOR);
        grid[y][x] = type;
    }
}

/** INPUT **/
canvas.addEventListener('pointerdown', e => {
    if(!playerTurn || gameOver) return;
    const scale = Math.min(canvas.width/(12*TILE), canvas.height/(12*TILE));
    const ox = (canvas.width - 12*TILE*scale)/2, oy = (canvas.height - 12*TILE*scale)/2;
    const tx = Math.floor(((e.clientX - ox)/scale)/TILE), ty = Math.floor(((e.clientY - oy)/scale)/TILE);

    if (tx < 0 || ty < 0 || tx >= 12 || ty >= 12) return;

    const d = Math.hypot(tx-player.x, ty-player.y);
    
    if(selectMode === 'move' && d > 0 && d < 2.5) {
        playerTurn = false; stats.turns++;
        animMove(player, tx, ty, () => { checkTile(); endTurn(); });
    } else if(selectMode !== 'move' && d < 1.5 && grid[ty][tx] === FLOOR) {
        deployTool(tx, ty);
    }
});

function deployTool(tx, ty) {
    if(selectMode === 'trap' && inv.trap > 0) { grid[ty][tx] = TRAP; inv.trap--; log("Trap Set."); }
    else if(selectMode === 'rice' && inv.rice > 0) { grid[ty][tx] = RICE; inv.rice--; log("Poison Rice set."); }
    else if(selectMode === 'bomb' && inv.bomb > 0) { grid[ty][tx] = BOMB; inv.bomb--; activeTools.push({x:tx,y:ty,type:'bomb',t:2}); log("Bomb armed (2 Turns)."); }
    else if(selectMode === 'crack' && inv.crack > 0) { grid[ty][tx] = CRACK; inv.crack--; activeTools.push({x:tx,y:ty,type:'crack',t:2,u:2}); log("Cracker set."); }
    else return;
    
    updateUI(); playerTurn = false; endTurn();
}

/** LOGIC **/
async function endTurn() {
    // Enemy Phase
    for(let e of enemies.filter(en => en.alive)) {
        await new Promise(r => setTimeout(r, 100));
        
        // Tool trigger
        const t = grid[e.y][e.x];
        if(t === TRAP || t === RICE) {
            e.alive = false; grid[e.y][e.x] = FLOOR; stats.kills++;
            spawnPart(e.x, e.y, "#f00", 20); shake=10;
            log("Enemy eliminated."); continue;
        }

        // Lure check
        if(!e.target) {
            for(let scanY=e.y-3; scanY<=e.y+3; scanY++) 
            for(let scanX=e.x-3; scanX<=e.x+3; scanX++) 
                if(scanX>=0 && scanY>=0 && scanX<12 && scanY<12 && grid[scanY][scanX] === RICE) e.target = {x:scanX, y:scanY};
        }

        let nx = e.x, ny = e.y;
        if(e.target) {
            if(nx < e.target.x) nx++; else if(nx > e.target.x) nx--;
            else if(ny < e.target.y) ny++; else if(ny > e.target.y) ny--;
            if(nx == e.target.x && ny == e.target.y) e.target = null;
        } else {
            const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
            const d = dirs[Math.floor(Math.random()*4)];
            if(grid[e.y+d.y]?.[e.x+d.x] === FLOOR) { nx+=d.x; ny+=d.y; }
        }
        
        await new Promise(r => animMove(e, nx, ny, r));
        if(!player.hidden && hasLineOfSight(e, player.x, player.y)) triggerDeath();
    }

    // Process Tools
    activeTools.forEach((tool, i) => {
        tool.t--;
        if(tool.t <= 0) {
            if(tool.type === 'bomb') {
                spawnPart(tool.x, tool.y, "#f50", 50); shake=20;
                grid[tool.y][tool.x] = FLOOR;
                enemies.forEach(en => { if(Math.hypot(en.x-tool.x, en.y-tool.y) < 8) en.target = {x:tool.x, y:tool.y}; });
                activeTools.splice(i, 1);
                log("BOMB EXPLODED");
            } else {
                spawnPart(tool.x, tool.y, "#fff", 15);
                enemies.forEach(en => { if(Math.hypot(en.x-tool.x, en.y-tool.y) < 6) en.target = {x:tool.x, y:tool.y}; });
                tool.u--;
                if(tool.u <= 0) { grid[tool.y][tool.x] = FLOOR; activeTools.splice(i, 1); } else tool.t = 2;
                log("CRACKER POP");
            }
        }
    });

    playerTurn = true;
    setMode('move');
}

function checkTile() {
    const t = grid[player.y][player.x];
    player.hidden = (t === HIDE);
    if(t === EXIT) win();
    if(t === COIN) { stats.coins++; grid[player.y][player.x] = FLOOR; log("Coin +1"); }
    if(t === NOISE) { log("!! LOUD NOISE !!"); enemies.forEach(e => e.target = {x:player.x, y:player.y}); }
    if(t === CHEST) {
        grid[player.y][player.x] = FLOOR;
        if(Math.random() < 0.6) {
            const loot = ['trap','rice','bomb','crack'][Math.floor(Math.random()*4)];
            inv[loot] += 2; log("FOUND BUNDLE: " + loot.toUpperCase());
        } else {
            log("CHEST WAS TRAPPED!");
            enemies.forEach(e => e.target = {x:player.x, y:player.y});
            shake = 15;
        }
        updateUI();
    }
}

/** RENDER **/
function loop() {
    draw();
    if(!gameOver) requestAnimationFrame(loop);
}

function draw() {
    const scale = Math.min(canvas.width/(12*TILE), canvas.height/(12*TILE));
    const ox = (canvas.width - 12*TILE*scale)/2 + (Math.random()-0.5)*shake;
    const oy = (canvas.height - 12*TILE*scale)/2 + (Math.random()-0.5)*shake;
    shake *= 0.9;

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.translate(ox, oy); ctx.scale(scale, scale);

    // Draw Grid
    for(let y=0; y<12; y++) for(let x=0; x<12; x++) {
        const dist = Math.hypot(x-player.x, y-player.y);
        ctx.globalAlpha = dist > 5 ? 0.2 : 1.0; // Fog of War

        ctx.fillStyle = grid[y][x] === WALL ? "#1a1a24" : "#08080c";
        ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        
        if(grid[y][x] === EXIT) drawIcon(x, y, "‚õ©Ô∏è", "#0f0");
        if(grid[y][x] === COIN) drawIcon(x, y, "ü™ô", "#ff0");
        if(grid[y][x] === HIDE) drawIcon(x, y, "üåø", "#05a");
        if(grid[y][x] === TRAP) drawIcon(x, y, "ü™§", "#f0f");
        if(grid[y][x] === RICE) drawIcon(x, y, "üçô", "#fff");
        if(grid[y][x] === BOMB) drawIcon(x, y, "üí£", "#f50");
        if(grid[y][x] === CRACK) drawIcon(x, y, "üéá", "#0af");
        if(grid[y][x] === CHEST) drawIcon(x, y, "üì¶", "#da0");
        if(grid[y][x] === NOISE) drawIcon(x, y, "üîî", "#f00");
    }
    ctx.globalAlpha = 1;

    // Movement Range
    if(playerTurn) {
        ctx.fillStyle = selectMode==='move' ? "rgba(0,170,255,0.1)" : "rgba(255,170,0,0.1)";
        const r = selectMode==='move' ? 2.5 : 1.5;
        for(let y=0; y<12; y++) for(let x=0; x<12; x++) {
            if(Math.hypot(x-player.x, y-player.y) < r && grid[y][x] === FLOOR) ctx.fillRect(x*TILE+2, y*TILE+2, TILE-4, TILE-4);
        }
    }

    // Entities
    enemies.forEach(e => {
        if(!e.alive) return;
        ctx.fillStyle = "rgba(255,0,0,0.15)";
        ctx.beginPath(); ctx.moveTo(e.ax*TILE+25, e.ay*TILE+25);
        const a = Math.atan2(e.dir.y, e.dir.x);
        ctx.arc(e.ax*TILE+25, e.ay*TILE+25, e.range*TILE, a-0.5, a+0.5); ctx.fill();
        drawIcon(e.ax, e.ay, "üë∫", "#f33");
    });

    drawIcon(player.ax, player.ay, player.hidden ? "üë§" : "ü•∑", "#0af");

    // Particles
    particles.forEach((p, i) => {
        p.update(); p.draw(ctx);
        if(p.life <= 0) particles.splice(i, 1);
    });
}

/** HELPERS **/
function drawIcon(x, y, ico, color) {
    ctx.fillStyle = color; ctx.font = "24px Arial"; ctx.textAlign = "center";
    ctx.fillText(ico, x*TILE+25, y*TILE+33);
}

function animMove(obj, tx, ty, cb) {
    const sx = obj.ax, sy = obj.ay;
    let p = 0;
    if(obj !== player) obj.dir = {x: Math.sign(tx-obj.x), y: Math.sign(ty-obj.y)};
    function step() {
        p += 0.15;
        obj.ax = sx + (tx-sx)*p;
        obj.ay = sy + (ty-sy)*p;
        if(p < 1) requestAnimationFrame(step);
        else { obj.x = tx; obj.y = ty; obj.ax = tx; obj.ay = ty; cb(); }
    }
    step();
}

function hasLineOfSight(e, px, py) {
    const dx = px-e.x, dy = py-e.y, d = Math.hypot(dx, dy);
    if(d > e.range) return false;
    const a = Math.abs(Math.atan2(dy, dx) - Math.atan2(e.dir.y, e.dir.x));
    if(a > 0.6 && a < 5.6) return false;
    return true;
}

function spawnPart(x, y, c, count) {
    for(let i=0; i<count; i++) particles.push(new Particle(x*TILE+25, y*TILE+25, c, 5, 30));
}

class Particle {
    constructor(x, y, color, s, l) {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random()-0.5)*s; this.vy = (Math.random()-0.5)*s;
        this.life = l; this.max = l;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
    draw(ctx) { ctx.globalAlpha = this.life/this.max; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, 4, 4); ctx.globalAlpha = 1; }
}

function setMode(m) {
    selectMode = m;
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('btn' + m.charAt(0).toUpperCase() + m.slice(1)).classList.add('active');
}

function updateUI() {
    document.getElementById('c-trap').innerText = inv.trap;
    document.getElementById('c-rice').innerText = inv.rice;
    document.getElementById('c-bomb').innerText = inv.bomb;
    document.getElementById('c-crack').innerText = inv.crack;
}

function log(m) {
    const el = document.getElementById('msgLog');
    el.innerHTML = `<div class="log">> ${m}</div>` + el.innerHTML;
    if(el.childNodes.length > 4) el.removeChild(el.lastChild);
}

function triggerDeath() {
    gameOver = true; shake = 30;
    document.getElementById('gameOverScreen').classList.remove('hidden');
}

function win() {
    gameOver = true;
    const score = (stats.coins * 200) + (stats.kills * 300) - (stats.turns * 10);
    const rank = score > 1500 ? "GHOST OF THE HOUSE" : score > 1000 ? "MASTER ASSASSIN" : "ACOLYTE";
    
    document.getElementById('stats').innerHTML = `
        Turns: ${stats.turns}<br>
        Kills: ${stats.kills}<br>
        Coins: ${stats.coins}<br>
        Score: ${score}
    `;
    document.getElementById('winTitle').innerText = rank;
    document.getElementById('resultScreen').classList.remove('hidden');
    stats.floors++;
}

function playerWait() { if(playerTurn) { playerTurn = false; stats.turns++; endTurn(); } }
</script>
</body>
</html>
