<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Silent House: Mobile Stealth</title>
<style>
body{margin:0;background:#111;color:#eee;font-family:monospace;text-align:center;touch-action:none;overscroll-behavior:none;}
canvas{display:block;margin:0 auto;background:#222;}
button{padding:8px 14px;margin:4px;background:#333;color:#eee;border:1px solid #666;}
.hidden{display:none;}
#controls{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);z-index:10;}
#controls button{width:60px;height:60px;font-size:20px;margin:4px;}
#info{position:fixed;top:10px;left:50%;transform:translateX(-50%);max-width:90%;z-index:10;}
.message{background:rgba(0,0,0,0.8);padding:4px 8px;border-radius:4px;color:#fff;font-size:14px;margin-bottom:2px;opacity:1;transition:opacity 2s;}
</style>
</head>
<body>

<h2>Silent House: Mobile Stealth</h2>

<div id="menu">
<p>Level: <span id="levelText">1</span></p>
<button onclick="changeLevel(-1)">−</button>
<button onclick="changeLevel(1)">+</button><br><br>
<p>Map Tiles:</p>
<input type="number" id="mapWidth" value="10" min="6" max="20"> x
<input type="number" id="mapHeight" value="10" min="6" max="20"><br><br>
<button onclick="startGame()">START</button>
</div>

<canvas id="game" width="960" height="960" class="hidden"></canvas>

<div id="controls" class="hidden">
<button onclick="playerWait()">Wait</button>
<button onclick="backToMenu()">Back</button>
</div>

<div id="info"></div>

<script>
/* ===== CONFIG ===== */
const TILE=48; // fixed size tile
const FLOOR=0,WALL=1,NOISE=2,EXIT=3,HIDE=4;

let levelNumber=1,grid,player,enemies,gameOver,playerTurn=true;
let mapW=10,mapH=10;

const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
const info=document.getElementById("info");

let camera={x:0,y:0,scale:1};
let dragging=false,lastX=0,lastY=0;

/* ===== MENU ===== */
function changeLevel(v){levelNumber=Math.max(1,levelNumber+v);levelText.textContent=levelNumber;}
function startGame(){
  mapW=Math.min(Math.max(parseInt(document.getElementById("mapWidth").value),6),20);
  mapH=Math.min(Math.max(parseInt(document.getElementById("mapHeight").value),6),20);
  canvas.width=TILE*mapW;
  canvas.height=TILE*mapH;
  camera.scale=Math.min(window.innerWidth/(TILE*mapW), window.innerHeight/(TILE*mapH),1);
  camera.x=0; camera.y=0;
  menu.classList.add("hidden");
  canvas.classList.remove("hidden");
  controls.classList.remove("hidden");
  generateLevel();
}
function backToMenu(){menu.classList.remove("hidden");canvas.classList.add("hidden");controls.classList.add("hidden");clearMessages();}

/* ===== LEVEL GENERATION ===== */
function generateLevel(){
  gameOver=false; playerTurn=true;
  grid=Array.from({length:mapH},(_,y)=>Array.from({length:mapW},(_,x)=>(x===0||y===0||x===mapW-1||y===mapH-1)?WALL:Math.random()<0.15?WALL:FLOOR));

  // Exit position
  let exitX,exitY;
  do{exitX=Math.floor(Math.random()*mapW); exitY=Math.floor(Math.random()*mapH);}while(grid[exitY][exitX]!==FLOOR);
  grid[exitY][exitX]=EXIT;

  // Player far from exit
  let px,py;
  do{px=Math.floor(Math.random()*mapW); py=Math.floor(Math.random()*mapH);}
  while(grid[py][px]!==FLOOR || Math.abs(px-exitX)+Math.abs(py-exitY)<Math.floor(Math.max(mapW,mapH)/2));
  player={x:px,y:py,hidden:false};

  // Noise/Hide
  for(let i=0;i<levelNumber+1;i++) placeRandom(NOISE);
  for(let i=0;i<Math.max(1,Math.floor(levelNumber/2));i++) placeRandom(HIDE);

  // Enemies near exit
  enemies=[];
  const count=Math.min(1+Math.floor(levelNumber/2),6);
  for(let i=0;i<count;i++){
    let ex,ey;
    do{
      ex=Math.floor(exitX + (Math.random()*3|0)-1);
      ey=Math.floor(exitY + (Math.random()*3|0)-1);
    }while(ex<0||ey<0||ex>=mapW||ey>=mapH||grid[ey][ex]!==FLOOR||enemies.some(e=>e.x===ex&&e.y===ey));
    enemies.push({x:ex,y:ey,dir:[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}][Math.floor(Math.random()*4)],target:null,alert:0,vision:3});
  }

  showMessage(`Level ${levelNumber} • Enemies ${count}`);
  draw();
}

function placeRandom(type){
  let x,y;
  do{x=Math.floor(Math.random()*mapW);y=Math.floor(Math.random()*mapH);}while(grid[y][x]!==FLOOR||(x===player.x && y===player.y));
  grid[y][x]=type;
}

/* ===== MESSAGES ===== */
function showMessage(text){
  const msg=document.createElement("div"); msg.className="message"; msg.textContent=text;
  info.appendChild(msg);
  if(info.childElementCount>5) info.removeChild(info.firstChild);
  setTimeout(()=>{msg.style.opacity=0; setTimeout(()=>msg.remove(),2000);},2000);
}
function clearMessages(){info.innerHTML="";}

/* ===== PLAYER ===== */
function getMovableTiles(){
  const tiles=[];
  for(let dx=-2;dx<=2;dx++)for(let dy=-2;dy<=2;dy++){
    const nx=player.x+dx,ny=player.y+dy;
    if(nx>=0&&ny>=0&&nx<mapW&&ny<mapH && grid[ny][nx]!==WALL && Math.abs(dx)+Math.abs(dy)<=2 && !(dx===0&&dy===0)) tiles.push({x:nx,y:ny});
  }
  return tiles;
}

canvas.addEventListener("click",e=>{
  if(!playerTurn||gameOver)return;
  const rect=canvas.getBoundingClientRect();
  const mx=Math.floor((e.clientX-rect.left)/TILE);
  const my=Math.floor((e.clientY-rect.top)/TILE);
  const target=getMovableTiles().find(t=>t.x===mx && t.y===my);
  if(target) movePlayerTo(target.x,target.y);
});

function movePlayerTo(tx, ty){
    playerTurn=false; 
    showMessage("Moving...");
    
    const path = [];
    let cx = player.x;
    let cy = player.y;
    
    // move horizontally first
    while(cx !== tx){
        cx += (tx > cx ? 1 : -1);
        path.push({x: cx, y: cy});
    }
    // then move vertically
    while(cy !== ty){
        cy += (ty > cy ? 1 : -1);
        path.push({x: cx, y: cy});
    }
    
    animateMovement(path, postPlayerMove);
}

function animateMovement(path, callback){
    if(path.length === 0){ callback(); return; }
    const p = path.shift();
    player.x = p.x;
    player.y = p.y;
    draw();
    setTimeout(() => animateMovement(path, callback), 150);
}

function playerWait(){if(!playerTurn||gameOver)return; showMessage("Waiting...");playerTurn=false; setTimeout(enemyTurn,300);}

function postPlayerMove(){
  player.hidden=grid[player.y][player.x]===HIDE;
  if(grid[player.y][player.x]===NOISE){
    enemies.forEach(e=>{
      const dist=Math.abs(e.x-player.x)+Math.abs(e.y-player.y);
      if(dist<=2){e.target={x:player.x,y:player.y}; e.alert=3; showMessage("Enemy investigates nearby noise!");}
    });
  }
  if(grid[player.y][player.x]===EXIT){ showMessage("Escaped!"); gameOver=true; levelNumber++; setTimeout(startGame,1000); return; }
  setTimeout(enemyTurn,300);
}

/* ===== ENEMIES ===== */
function enemyTurn(){
  if(gameOver) return;
  showMessage("Enemy Turn...");
  let index=0;
  function nextEnemy(){
    if(index>=enemies.length){playerTurn=true; showMessage("Your Turn"); draw(); return;}
    const e=enemies[index++];
    if(!player.hidden && canSee(e)){ showMessage("You were seen!"); gameOver=true; return;}
    moveEnemy(e,nextEnemy);
  }
  nextEnemy();
}

function moveEnemy(e,callback){
  let tx=e.x,ty=e.y;
  if(e.target){tx=e.target.x; ty=e.target.y;}
  else{
    const nx=e.x+e.dir.x, ny=e.y+e.dir.y;
    if(nx>=0&&ny>=0&&nx<mapW&&ny<mapH && grid[ny][nx]!==WALL){tx=nx; ty=ny;} else {e.dir.x*=-1; e.dir.y*=-1; tx=e.x+e.dir.x; ty=e.y+e.dir.y;}
  }
  e.x=tx; e.y=ty; if(e.alert>0) e.alert--; draw();
  setTimeout(callback,200);
}

function canSee(e){
  for(let i=1;i<=e.vision;i++){
    const x=e.x+e.dir.x*i, y=e.y+e.dir.y*i;
    if(x<0||y<0||x>=mapW||y>=mapH || grid[y][x]===WALL) break;
    if(x===player.x && y===player.y){ e.alert=3; return true; }
  }
  return false;
}

/* ===== DRAW ===== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(camera.x,camera.y);
  ctx.scale(camera.scale,camera.scale);

  // tiles
  for(let y=0;y<mapH;y++)for(let x=0;x<mapW;x++){
    ctx.fillStyle=
      grid[y][x]===WALL?"#555":
      grid[y][x]===HIDE?"#000":
      grid[y][x]===NOISE?"#222":
      grid[y][x]===EXIT?"#0a0":"#222";
    ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
  }

  // highlight movable tiles
  if(playerTurn)getMovableTiles().forEach(t=>{
    ctx.fillStyle="rgba(0,150,255,0.3)";
    ctx.fillRect(t.x*TILE,t.y*TILE,TILE,TILE);
  });

  // enemies
  enemies.forEach(e=>{
    if(e.alert>0){
      ctx.strokeStyle="red"; ctx.lineWidth=3; ctx.strokeRect(e.x*TILE,e.y*TILE,TILE,TILE);
      ctx.fillStyle="red"; ctx.font="14px monospace"; ctx.fillText("ALERT!",e.x*TILE,e.y*TILE-2);
    }
    ctx.fillStyle="#f00"; ctx.fillRect(e.x*TILE+12,e.y*TILE+12,24,24);
  });

  // player
  ctx.fillStyle=player.hidden?"#00a":"#0af";
  ctx.fillRect(player.x*TILE+12,player.y*TILE+12,24,24);

  ctx.restore();
}

/* ===== CAMERA TOUCH ===== */
canvas.addEventListener("pointerdown",e=>{dragging=true; lastX=e.clientX; lastY=e.clientY;});
canvas.addEventListener("pointermove",e=>{if(dragging){camera.x+=e.clientX-lastX;camera.y+=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY; draw();}});
canvas.addEventListener("pointerup",()=>{dragging=false;});
canvas.addEventListener("pointercancel",()=>{dragging=false;});
canvas.addEventListener("wheel",e=>{camera.scale=Math.max(0.5,Math.min(2,camera.scale*(1-e.deltaY*0.001))); draw(); e.preventDefault();},{passive:false});

</script>
</body>
</html>