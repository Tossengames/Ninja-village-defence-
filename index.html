<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Silent House: Shadow Protocol</title>
<style>
    :root { --accent: #d4af37; --bg: #050505; --ink: #1a1a1a; }
    body { margin: 0; background: var(--bg); color: #eee; font-family: 'Palatino', 'Georgia', serif; overflow: hidden; touch-action: none; }
    canvas { display: block; margin: 0 auto; image-rendering: pixelated; background: #000; }
    
    /* Tenchu Style Result Screen */
    .overlay-screen { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 20; }
    .scroll-bg { background: #e8dcc4; color: var(--ink); padding: 40px; border: 4px double #5c4033; width: 300px; box-shadow: 0 0 50px rgba(0,0,0,1); text-align: center; border-radius: 5px; }
    .hidden { display: none !important; }

    .rank-text { font-size: 32px; font-weight: bold; color: #8b0000; border-bottom: 2px solid #8b0000; margin-bottom: 20px; text-transform: uppercase; }
    .stats-row { display: flex; justify-content: space-between; margin: 10px 0; border-bottom: 1px dashed #aaa; font-size: 14px; }
    
    #toolbar { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; z-index: 10; background: rgba(20,20,20,0.9); padding: 10px; border: 1px solid #d4af37; border-radius: 4px; }
    .tool-btn { width: 55px; height: 65px; background: #111; border: 1px solid #444; color: #888; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 10px; cursor: pointer; }
    .tool-btn.active { border-color: var(--accent); color: var(--accent); }
    
    .btn-main { padding: 10px 20px; background: #1a1a1a; color: #d4af37; border: 1px solid #d4af37; cursor: pointer; font-family: inherit; margin-top: 20px; }
</style>
</head>
<body>

<div id="menu" class="overlay-screen">
    <h1 style="color:var(--accent); letter-spacing: 5px; text-shadow: 2px 2px 0px #000;">NINJA SELECTION</h1>
    <div style="margin: 10px;">Traps: <input type="number" id="inpTraps" value="2" style="width:40px"> Rice: <input type="number" id="inpRice" value="2" style="width:40px"></div>
    <div style="margin: 10px;">Bombs: <input type="number" id="inpBombs" value="1" style="width:40px"> Crackers: <input type="number" id="inpCracks" value="2" style="width:40px"></div>
    <button class="btn-main" onclick="initGame()">INFILTRATE</button>
</div>

<div id="resultScreen" class="overlay-screen hidden">
    <div class="scroll-bg">
        <div id="rankLabel" class="rank-text">Grand Master</div>
        <div id="statsContent"></div>
        <button class="btn-main" onclick="location.reload()">NEXT MISSION</button>
    </div>
</div>

<div id="gameOverScreen" class="overlay-screen hidden">
    <h1 style="color:#8b0000; letter-spacing: 10px;">YOU ARE DEAD</h1>
    <button class="btn-main" onclick="location.reload()">RETRY</button>
</div>

<canvas id="game"></canvas>

<div id="toolbar" class="hidden">
    <div class="tool-btn active" id="btnMove" onclick="setMode('move')"><b>üë§</b>Move</div>
    <div class="tool-btn" id="btnTrap" onclick="setMode('trap')"><b>ü™§</b><span id="c-trap">0</span></div>
    <div class="tool-btn" id="btnRice" onclick="setMode('rice')"><b>üçô</b><span id="c-rice">0</span></div>
    <div class="tool-btn" id="btnBomb" onclick="setMode('bomb')"><b>üí£</b><span id="c-bomb">0</span></div>
    <div class="tool-btn" id="btnCrack" onclick="setMode('crack')"><b>üéá</b><span id="c-crack">0</span></div>
    <div class="tool-btn" onclick="playerWait()"><b>‚è≥</b>Wait</div>
</div>

<script>
const sprites = {};
const spriteNames = ['player', 'guard', 'wall', 'floor', 'exit', 'trap', 'rice', 'bomb', 'chest', 'coin'];
let loadedCount = 0;

/** ASSET MANAGEMENT **/
function preloadSprites(callback) {
    spriteNames.forEach(name => {
        const img = new Image();
        img.src = `sprites/${name}.png`;
        img.onload = () => { loadedCount++; if (loadedCount === spriteNames.length) callback(); };
        img.onerror = () => { 
            console.warn(`Sprite missing: ${name}. Using placeholder.`);
            sprites[name] = null; // Mark as null to trigger placeholder
            loadedCount++; 
            if (loadedCount === spriteNames.length) callback(); 
        };
        sprites[name] = img;
    });
}

/** DRAWING WITH PLACEHOLDER LOGIC **/
function drawSprite(name, x, y) {
    const img = sprites[name];
    const px = x * TILE, py = y * TILE;

    if (img && img.complete && img.naturalWidth !== 0) {
        ctx.drawImage(img, px, py, TILE, TILE);
    } else {
        // FALLBACKS if folder is missing
        ctx.beginPath();
        switch(name) {
            case 'floor': ctx.fillStyle = '#111'; ctx.fillRect(px, py, TILE, TILE); break;
            case 'wall': ctx.fillStyle = '#333'; ctx.fillRect(px, py, TILE, TILE); break;
            case 'player': ctx.fillStyle = '#0af'; ctx.arc(px+25, py+25, 15, 0, Math.PI*2); ctx.fill(); break;
            case 'guard': ctx.fillStyle = '#f00'; ctx.arc(px+25, py+25, 15, 0, Math.PI*2); ctx.fill(); break;
            case 'exit': ctx.strokeStyle = '#0f0'; ctx.strokeRect(px+10, py+10, 30, 30); break;
            case 'trap': ctx.fillStyle = '#f0f'; ctx.fillRect(px+15, py+15, 20, 20); break;
            case 'rice': ctx.fillStyle = '#fff'; ctx.arc(px+25, py+25, 8, 0, Math.PI*2); ctx.fill(); break;
            case 'bomb': ctx.fillStyle = '#f50'; ctx.arc(px+25, py+25, 12, 0, Math.PI*2); ctx.fill(); break;
            case 'chest': ctx.fillStyle = '#da0'; ctx.fillRect(px+10, py+15, 30, 25); break;
            case 'coin': ctx.fillStyle = '#ff0'; ctx.arc(px+25, py+25, 5, 0, Math.PI*2); ctx.fill(); break;
        }
    }
}

/** TENCHU RESULT LOGIC **/
function calculateTenchuRank(stats) {
    let score = 0;
    score += stats.kills * 100;
    score += stats.coins * 50;
    score -= stats.spotted * 150; // Getting spotted is a huge penalty in Tenchu
    score -= stats.turns * 2;

    let rank = "Thug";
    if (score >= 450) rank = "Grand Master";
    else if (score >= 300) rank = "Expert Ninja";
    else if (score >= 150) rank = "Journeyman";
    else if (score >= 0) rank = "Novice";

    return { rank, score };
}

function showResults() {
    gameOver = true;
    const { rank, score } = calculateTenchuRank(gameStats);
    
    document.getElementById('rankLabel').innerText = rank;
    document.getElementById('statsContent').innerHTML = `
        <div class="stats-row"><span>Eliminations</span> <span>${gameStats.kills}</span></div>
        <div class="stats-row"><span>Items Found</span> <span>${gameStats.coins}</span></div>
        <div class="stats-row"><span>Time (Turns)</span> <span>${gameStats.turns}</span></div>
        <div class="stats-row" style="color:red"><span>Spotted</span> <span>${gameStats.spotted}</span></div>
        <div class="stats-row" style="border:none; font-weight:bold; font-size:18px; margin-top:15px;">
            <span>TOTAL SCORE</span> <span>${score}</span>
        </div>
    `;
    
    document.getElementById('resultScreen').classList.remove('hidden');
    document.getElementById('toolbar').classList.add('hidden');
}

/** CORE CONSTANTS & GLOBALS **/
const TILE = 50;
const FLOOR=0, WALL=1, NOISE=2, EXIT=3, HIDE=4, COIN=5, TRAP=6, RICE=7, BOMB=8, CRACK=9, CHEST=10;

let grid, player, enemies, particles = [], activeTools = [];
let selectMode = 'move', playerTurn = true;
let gameStats = { turns: 0, kills: 0, coins: 0, spotted: 0 };
let inv = { trap: 0, rice: 0, bomb: 0, crack: 0 };
let mapDim = 12, shake = 0;

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

function initGame() {
    inv.trap = parseInt(document.getElementById('inpTraps').value);
    inv.rice = parseInt(document.getElementById('inpRice').value);
    inv.bomb = parseInt(document.getElementById('inpBombs').value);
    inv.crack = parseInt(document.getElementById('inpCracks').value);
    
    preloadSprites(() => {
        document.getElementById('menu').classList.add('hidden');
        document.getElementById('toolbar').classList.remove('hidden');
        generateLevel();
    });
}

function generateLevel() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    grid = Array.from({length: mapDim}, (_, y) => Array.from({length: mapDim}, (_, x) => 
        (x==0 || y==0 || x==mapDim-1 || y==mapDim-1) ? WALL : Math.random() < 0.18 ? WALL : FLOOR
    ));
    player = { x: 1, y: 1, ax: 1, ay: 1, hidden: false };
    grid[mapDim-2][mapDim-2] = EXIT;
    
    placeRandom(CHEST, 2);
    placeRandom(COIN, 4);
    placeRandom(NOISE, 3); // Invisible Bell

    enemies = [];
    for(let i=0; i<5; i++) {
        let ex, ey; do { ex = Math.floor(Math.random()*(mapDim-2))+1; ey = Math.floor(Math.random()*(mapDim-2))+1; }
        while(grid[ey][ex] !== FLOOR || Math.hypot(ex-1, ey-1) < 4);
        enemies.push({ x: ex, y: ey, ax: ex, ay: ey, dir: {x:1, y:0}, target: null, alive: true, range: 4, status: "Patrolling", bubble: "" });
    }
    updateUI();
    requestAnimationFrame(gameLoop);
}

function placeRandom(type, count) {
    for(let i=0; i<count; i++) {
        let x, y; do { x = Math.floor(Math.random()*(mapDim-2))+1; y = Math.floor(Math.random()*(mapDim-2))+1; } while(grid[y][x] !== FLOOR);
        grid[y][x] = type;
    }
}

/** INTERACTION **/
canvas.addEventListener('pointerdown', e => {
    if(!playerTurn || gameOver) return;
    const scale = Math.min(canvas.width/(mapDim*TILE), canvas.height/(mapDim*TILE));
    const ox = (canvas.width - mapDim*TILE*scale)/2, oy = (canvas.height - mapDim*TILE*scale)/2;
    const tx = Math.floor(((e.clientX - ox)/scale)/TILE), ty = Math.floor(((e.clientY - oy)/scale)/TILE);

    if (tx < 0 || ty < 0 || tx >= mapDim || ty >= mapDim) return;
    const dist = Math.hypot(tx-player.x, ty-player.y);
    
    if(selectMode === 'move' && dist > 0 && dist < 2.5) {
        playerTurn = false; gameStats.turns++;
        animMove(player, tx, ty, () => { checkTile(); endTurn(); });
    } else if(selectMode !== 'move' && dist < 1.5 && grid[ty][tx] === FLOOR) {
        deployTool(tx, ty);
    }
});

function deployTool(tx, ty) {
    if(selectMode === 'trap' && inv.trap > 0) { grid[ty][tx] = TRAP; inv.trap--; }
    else if(selectMode === 'rice' && inv.rice > 0) { grid[ty][tx] = RICE; inv.rice--; }
    else if(selectMode === 'bomb' && inv.bomb > 0) { grid[ty][tx] = BOMB; inv.bomb--; activeTools.push({x:tx,y:ty,type:'bomb',t:2}); }
    else return;
    updateUI(); playerTurn = false; endTurn();
}

/** GAME CYCLE **/
async function endTurn() {
    for(let e of enemies.filter(en => en.alive)) {
        await new Promise(r => setTimeout(r, 80));
        
        // Trap check
        if(grid[e.y][e.x] === TRAP || grid[e.y][e.x] === RICE) {
            let wasRice = grid[e.y][e.x] === RICE;
            e.alive = false; grid[e.y][e.x] = FLOOR; gameStats.kills++;
            if(wasRice) enemies.forEach(o => { if(o.target && o.target.x === e.x && o.target.y === e.y) o.target = null; });
            continue;
        }

        let nx = e.x, ny = e.y;
        if(e.target) {
            if(nx < e.target.x) nx++; else if(nx > e.target.x) nx--;
            else if(ny < e.target.y) ny++; else if(ny > e.target.y) ny--;
            if(nx == e.target.x && ny == e.target.y) e.target = null;
        } else {
            const d = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}][Math.floor(Math.random()*4)];
            if(grid[e.y+d.y]?.[e.x+d.x] === FLOOR) { nx+=d.x; ny+=d.y; }
        }
        await new Promise(r => animMove(e, nx, ny, r));
        if(!player.hidden && hasLineOfSight(e, player.x, player.y)) { gameStats.spotted++; triggerDeath(); return; }
    }
    playerTurn = true;
}

function checkTile() {
    const t = grid[player.y][player.x];
    if(t === EXIT) showResults();
    if(t === COIN) { gameStats.coins++; grid[player.y][player.x] = FLOOR; }
    if(t === NOISE) { shake = 15; enemies.forEach(e => { if(e.alive) e.target = {x:player.x, y:player.y}; }); }
}

function gameLoop() { if(!gameOver) { draw(); requestAnimationFrame(gameLoop); } }

function draw() {
    const scale = Math.min(canvas.width/(mapDim*TILE), canvas.height/(mapDim*TILE));
    const ox = (canvas.width - mapDim*TILE*scale)/2 + (Math.random()-0.5)*shake;
    const oy = (canvas.height - mapDim*TILE*scale)/2 + (Math.random()-0.5)*shake;
    shake *= 0.9;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.translate(ox, oy); ctx.scale(scale, scale);

    for(let y=0; y<mapDim; y++) for(let x=0; x<mapDim; x++) {
        drawSprite('floor', x, y);
        if(grid[y][x] !== FLOOR && grid[y][x] !== NOISE) {
            const names = ['', 'wall', '', 'exit', '', 'coin', 'trap', 'rice', 'bomb', '', 'chest'];
            drawSprite(names[grid[y][x]], x, y);
        }
    }

    enemies.forEach(e => {
        if(!e.alive) return;
        drawSprite('guard', e.ax, e.ay);
        // Vision Cone
        ctx.fillStyle = "rgba(255,0,0,0.1)"; ctx.beginPath(); ctx.moveTo(e.ax*TILE+25, e.ay*TILE+25);
        const baseA = Math.atan2(e.dir.y, e.dir.x);
        for(let a = baseA-0.5; a <= baseA+0.5; a += 0.1) {
            let d = 0; while(d < e.range) { d += 0.2; if(grid[Math.floor(e.y + Math.sin(a)*d)]?.[Math.floor(e.x + Math.cos(a)*d)] === WALL) break; }
            ctx.lineTo(e.ax*TILE+25 + Math.cos(a)*d*TILE, e.ay*TILE+25 + Math.sin(a)*d*TILE);
        }
        ctx.fill();
    });

    drawSprite('player', player.ax, player.ay);
}

/** HELPERS **/
function animMove(obj, tx, ty, cb) {
    const sx = obj.ax, sy = obj.ay; let p = 0;
    if(obj !== player) obj.dir = {x: Math.sign(tx-obj.x), y: Math.sign(ty-obj.y) || obj.dir.y};
    function step() {
        p += 0.2; obj.ax = sx + (tx-sx)*p; obj.ay = sy + (ty-sy)*p;
        if(p < 1) requestAnimationFrame(step); else { obj.x = tx; obj.y = ty; obj.ax = tx; obj.ay = ty; cb(); }
    }
    step();
}

function hasLineOfSight(e, px, py) {
    const dx = px-e.x, dy = py-e.y, dist = Math.hypot(dx, dy);
    if(dist > e.range) return false;
    const ang = Math.abs(Math.atan2(dy, dx) - Math.atan2(e.dir.y, e.dir.x));
    if(ang > 0.6 && ang < 5.6) return false;
    for(let d=0.5; d<dist; d+=0.5) if(grid[Math.floor(e.y + (dy/dist)*d)]?.[Math.floor(e.x + (dx/dist)*d)] === WALL) return false;
    return true;
}

function updateUI() {
    document.getElementById('c-trap').innerText = inv.trap;
    document.getElementById('c-rice').innerText = inv.rice;
    document.getElementById('c-bomb').innerText = inv.bomb;
    document.getElementById('c-crack').innerText = inv.crack;
}

function triggerDeath() { gameOver = true; document.getElementById('gameOverScreen').classList.remove('hidden'); }
function setMode(m) { selectMode = m; document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active')); document.getElementById('btn' + m.charAt(0).toUpperCase() + m.slice(1)).classList.add('active'); }
function playerWait() { if(playerTurn) { playerTurn = false; gameStats.turns++; endTurn(); } }
</script>
</body>
</html>
